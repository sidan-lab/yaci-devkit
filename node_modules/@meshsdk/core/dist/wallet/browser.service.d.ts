import { IInitiator, ISigner, ISubmitter } from '@mesh/common/contracts';
import type { Address, TransactionUnspentOutput } from '@mesh/core';
import type { Asset, AssetExtended, DataSignature, UTxO, Wallet } from '@mesh/common/types';
export declare class BrowserWallet implements IInitiator, ISigner, ISubmitter {
    readonly _walletInstance: WalletInstance;
    readonly _walletName: string;
    walletInstance: WalletInstance;
    private constructor();
    static getInstalledWallets(): Wallet[];
    static enable(walletName: string): Promise<BrowserWallet>;
    getBalance(): Promise<Asset[]>;
    getChangeAddress(): Promise<string>;
    getCollateral(limit?: number): Promise<UTxO[]>;
    getNetworkId(): Promise<number>;
    getRewardAddresses(): Promise<string[]>;
    getUnusedAddresses(): Promise<string[]>;
    getUsedAddresses(): Promise<string[]>;
    getUtxos(amount?: Asset[] | undefined): Promise<UTxO[]>;
    signData(address: string, payload: string): Promise<DataSignature>;
    signTx(unsignedTx: string, partialSign?: boolean): Promise<string>;
    /**
     * Experimental feature - sign multiple transactions at once (Supported wallet(s): Typhon)
     * @param unsignedTxs - array of unsigned transactions in CborHex string
     * @param partialSign - if the transactions are signed partially
     * @returns array of signed transactions CborHex string
     */
    signTxs(unsignedTxs: string[], partialSign?: boolean): Promise<string[]>;
    submitTx(tx: string): Promise<string>;
    getUsedAddress(): Promise<Address>;
    getUsedCollateral(limit?: number): Promise<TransactionUnspentOutput[]>;
    getUsedUTxOs(amount?: Asset[] | undefined): Promise<TransactionUnspentOutput[]>;
    getAssets(): Promise<AssetExtended[]>;
    getLovelace(): Promise<string>;
    getPolicyIdAssets(policyId: string): Promise<AssetExtended[]>;
    getPolicyIds(): Promise<string[]>;
    private static resolveInstance;
}
declare global {
    interface Window {
        cardano: Cardano;
    }
}
declare type Cardano = {
    [key: string]: {
        name: string;
        icon: string;
        apiVersion: string;
        enable: () => Promise<WalletInstance>;
    };
};
declare type TransactionSignatureRequest = {
    cbor: string;
    partialSign: boolean;
};
declare type WalletInstance = {
    experimental: ExperimentalFeatures;
    getBalance(): Promise<string>;
    getChangeAddress(): Promise<string>;
    getNetworkId(): Promise<number>;
    getRewardAddresses(): Promise<string[]>;
    getUnusedAddresses(): Promise<string[]>;
    getUsedAddresses(): Promise<string[]>;
    getUtxos(amount: string | undefined): Promise<string[] | undefined>;
    signData(address: string, payload: string): Promise<DataSignature>;
    signTx(tx: string, partialSign: boolean): Promise<string>;
    signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>;
    signTxs?(txs: string[], partialSign: boolean): Promise<string[]>;
    submitTx(tx: string): Promise<string>;
};
declare type ExperimentalFeatures = {
    getCollateral(): Promise<string[] | undefined>;
    signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>;
    signTxs?(txs: string[], partialSign: boolean): Promise<string[]>;
};
export {};
