import { customAlphabet as Ir } from "nanoid";
import * as i from "@emurgo/cardano-serialization-lib-nodejs";
import Mt from "axios";
import { mnemonicToEntropy as _r, generateMnemonic as Lr } from "bip39";
import { COSEKey as yr, COSESign1 as Gr, Label as Ut, Int as de, BigNum as ke, KeyType as Yr, AlgorithmId as xr, CBORValue as Te, HeaderMap as ze, Headers as $r, ProtectedHeaderMap as zr, COSESign1Builder as Jr } from "@emurgo/cardano-message-signing-nodejs";
const Wr = ["testnet", "preview", "preprod", "mainnet"], jr = (s) => Wr.includes(s), Gt = {
  mem: 7e6,
  steps: 3e9
}, ft = {
  epoch: 0,
  coinsPerUTxOSize: "4310",
  priceMem: 0.0577,
  priceStep: 721e-7,
  minFeeA: 44,
  minFeeB: 155381,
  keyDeposit: "2000000",
  maxTxSize: 16384,
  maxValSize: "5000",
  poolDeposit: "500000000",
  maxCollateralInputs: 3,
  decentralisation: 0,
  maxBlockSize: 98304,
  collateralPercent: 150,
  maxBlockHeaderSize: 1100,
  minPoolCost: "340000000",
  maxTxExMem: "16000000",
  maxTxExSteps: "10000000000",
  maxBlockExMem: "80000000",
  maxBlockExSteps: "40000000000"
}, Qe = 2147483648, St = {
  V1: i.Language.new_plutus_v1(),
  V2: i.Language.new_plutus_v2()
}, Ct = 56, Xr = {
  CERT: i.RedeemerTag.new_cert(),
  MINT: i.RedeemerTag.new_mint(),
  REWARD: i.RedeemerTag.new_reward(),
  SPEND: i.RedeemerTag.new_spend()
}, Ae = {
  testnet: ["74", "1598400", "1595967616", "432000"],
  preview: ["183", "15811222", "1682467200", "86400"],
  preprod: ["65", "26438400", "1682121600", "432000"],
  mainnet: ["208", "4492800", "1596059091", "432000"]
}, Je = {
  ALONZO: i.TxBuilderConstants.plutus_alonzo_cost_models(),
  BABBAGE: (() => {
    const s = i.Costmdls.new(), e = i.CostModel.new();
    Object.values({
      "addInteger-cpu-arguments-intercept": 205665,
      "addInteger-cpu-arguments-slope": 812,
      "addInteger-memory-arguments-intercept": 1,
      "addInteger-memory-arguments-slope": 1,
      "appendByteString-cpu-arguments-intercept": 1e3,
      "appendByteString-cpu-arguments-slope": 571,
      "appendByteString-memory-arguments-intercept": 0,
      "appendByteString-memory-arguments-slope": 1,
      "appendString-cpu-arguments-intercept": 1e3,
      "appendString-cpu-arguments-slope": 24177,
      "appendString-memory-arguments-intercept": 4,
      "appendString-memory-arguments-slope": 1,
      "bData-cpu-arguments": 1e3,
      "bData-memory-arguments": 32,
      "blake2b_256-cpu-arguments-intercept": 117366,
      "blake2b_256-cpu-arguments-slope": 10475,
      "blake2b_256-memory-arguments": 4,
      "cekApplyCost-exBudgetCPU": 23e3,
      "cekApplyCost-exBudgetMemory": 100,
      "cekBuiltinCost-exBudgetCPU": 23e3,
      "cekBuiltinCost-exBudgetMemory": 100,
      "cekConstCost-exBudgetCPU": 23e3,
      "cekConstCost-exBudgetMemory": 100,
      "cekDelayCost-exBudgetCPU": 23e3,
      "cekDelayCost-exBudgetMemory": 100,
      "cekForceCost-exBudgetCPU": 23e3,
      "cekForceCost-exBudgetMemory": 100,
      "cekLamCost-exBudgetCPU": 23e3,
      "cekLamCost-exBudgetMemory": 100,
      "cekStartupCost-exBudgetCPU": 100,
      "cekStartupCost-exBudgetMemory": 100,
      "cekVarCost-exBudgetCPU": 23e3,
      "cekVarCost-exBudgetMemory": 100,
      "chooseData-cpu-arguments": 19537,
      "chooseData-memory-arguments": 32,
      "chooseList-cpu-arguments": 175354,
      "chooseList-memory-arguments": 32,
      "chooseUnit-cpu-arguments": 46417,
      "chooseUnit-memory-arguments": 4,
      "consByteString-cpu-arguments-intercept": 221973,
      "consByteString-cpu-arguments-slope": 511,
      "consByteString-memory-arguments-intercept": 0,
      "consByteString-memory-arguments-slope": 1,
      "constrData-cpu-arguments": 89141,
      "constrData-memory-arguments": 32,
      "decodeUtf8-cpu-arguments-intercept": 497525,
      "decodeUtf8-cpu-arguments-slope": 14068,
      "decodeUtf8-memory-arguments-intercept": 4,
      "decodeUtf8-memory-arguments-slope": 2,
      "divideInteger-cpu-arguments-constant": 196500,
      "divideInteger-cpu-arguments-model-arguments-intercept": 453240,
      "divideInteger-cpu-arguments-model-arguments-slope": 220,
      "divideInteger-memory-arguments-intercept": 0,
      "divideInteger-memory-arguments-minimum": 1,
      "divideInteger-memory-arguments-slope": 1,
      "encodeUtf8-cpu-arguments-intercept": 1e3,
      "encodeUtf8-cpu-arguments-slope": 28662,
      "encodeUtf8-memory-arguments-intercept": 4,
      "encodeUtf8-memory-arguments-slope": 2,
      "equalsByteString-cpu-arguments-constant": 245e3,
      "equalsByteString-cpu-arguments-intercept": 216773,
      "equalsByteString-cpu-arguments-slope": 62,
      "equalsByteString-memory-arguments": 1,
      "equalsData-cpu-arguments-intercept": 1060367,
      "equalsData-cpu-arguments-slope": 12586,
      "equalsData-memory-arguments": 1,
      "equalsInteger-cpu-arguments-intercept": 208512,
      "equalsInteger-cpu-arguments-slope": 421,
      "equalsInteger-memory-arguments": 1,
      "equalsString-cpu-arguments-constant": 187e3,
      "equalsString-cpu-arguments-intercept": 1e3,
      "equalsString-cpu-arguments-slope": 52998,
      "equalsString-memory-arguments": 1,
      "fstPair-cpu-arguments": 80436,
      "fstPair-memory-arguments": 32,
      "headList-cpu-arguments": 43249,
      "headList-memory-arguments": 32,
      "iData-cpu-arguments": 1e3,
      "iData-memory-arguments": 32,
      "ifThenElse-cpu-arguments": 80556,
      "ifThenElse-memory-arguments": 1,
      "indexByteString-cpu-arguments": 57667,
      "indexByteString-memory-arguments": 4,
      "lengthOfByteString-cpu-arguments": 1e3,
      "lengthOfByteString-memory-arguments": 10,
      "lessThanByteString-cpu-arguments-intercept": 197145,
      "lessThanByteString-cpu-arguments-slope": 156,
      "lessThanByteString-memory-arguments": 1,
      "lessThanEqualsByteString-cpu-arguments-intercept": 197145,
      "lessThanEqualsByteString-cpu-arguments-slope": 156,
      "lessThanEqualsByteString-memory-arguments": 1,
      "lessThanEqualsInteger-cpu-arguments-intercept": 204924,
      "lessThanEqualsInteger-cpu-arguments-slope": 473,
      "lessThanEqualsInteger-memory-arguments": 1,
      "lessThanInteger-cpu-arguments-intercept": 208896,
      "lessThanInteger-cpu-arguments-slope": 511,
      "lessThanInteger-memory-arguments": 1,
      "listData-cpu-arguments": 52467,
      "listData-memory-arguments": 32,
      "mapData-cpu-arguments": 64832,
      "mapData-memory-arguments": 32,
      "mkCons-cpu-arguments": 65493,
      "mkCons-memory-arguments": 32,
      "mkNilData-cpu-arguments": 22558,
      "mkNilData-memory-arguments": 32,
      "mkNilPairData-cpu-arguments": 16563,
      "mkNilPairData-memory-arguments": 32,
      "mkPairData-cpu-arguments": 76511,
      "mkPairData-memory-arguments": 32,
      "modInteger-cpu-arguments-constant": 196500,
      "modInteger-cpu-arguments-model-arguments-intercept": 453240,
      "modInteger-cpu-arguments-model-arguments-slope": 220,
      "modInteger-memory-arguments-intercept": 0,
      "modInteger-memory-arguments-minimum": 1,
      "modInteger-memory-arguments-slope": 1,
      "multiplyInteger-cpu-arguments-intercept": 69522,
      "multiplyInteger-cpu-arguments-slope": 11687,
      "multiplyInteger-memory-arguments-intercept": 0,
      "multiplyInteger-memory-arguments-slope": 1,
      "nullList-cpu-arguments": 60091,
      "nullList-memory-arguments": 32,
      "quotientInteger-cpu-arguments-constant": 196500,
      "quotientInteger-cpu-arguments-model-arguments-intercept": 453240,
      "quotientInteger-cpu-arguments-model-arguments-slope": 220,
      "quotientInteger-memory-arguments-intercept": 0,
      "quotientInteger-memory-arguments-minimum": 1,
      "quotientInteger-memory-arguments-slope": 1,
      "remainderInteger-cpu-arguments-constant": 196500,
      "remainderInteger-cpu-arguments-model-arguments-intercept": 453240,
      "remainderInteger-cpu-arguments-model-arguments-slope": 220,
      "remainderInteger-memory-arguments-intercept": 0,
      "remainderInteger-memory-arguments-minimum": 1,
      "remainderInteger-memory-arguments-slope": 1,
      "sha2_256-cpu-arguments-intercept": 806990,
      "sha2_256-cpu-arguments-slope": 30482,
      "sha2_256-memory-arguments": 4,
      "sha3_256-cpu-arguments-intercept": 1927926,
      "sha3_256-cpu-arguments-slope": 82523,
      "sha3_256-memory-arguments": 4,
      "sliceByteString-cpu-arguments-intercept": 265318,
      "sliceByteString-cpu-arguments-slope": 0,
      "sliceByteString-memory-arguments-intercept": 4,
      "sliceByteString-memory-arguments-slope": 0,
      "sndPair-cpu-arguments": 85931,
      "sndPair-memory-arguments": 32,
      "subtractInteger-cpu-arguments-intercept": 205665,
      "subtractInteger-cpu-arguments-slope": 812,
      "subtractInteger-memory-arguments-intercept": 1,
      "subtractInteger-memory-arguments-slope": 1,
      "tailList-cpu-arguments": 41182,
      "tailList-memory-arguments": 32,
      "trace-cpu-arguments": 212342,
      "trace-memory-arguments": 32,
      "unBData-cpu-arguments": 31220,
      "unBData-memory-arguments": 32,
      "unConstrData-cpu-arguments": 32696,
      "unConstrData-memory-arguments": 32,
      "unIData-cpu-arguments": 43357,
      "unIData-memory-arguments": 32,
      "unListData-cpu-arguments": 32247,
      "unListData-memory-arguments": 32,
      "unMapData-cpu-arguments": 38314,
      "unMapData-memory-arguments": 32,
      "verifyEd25519Signature-cpu-arguments-intercept": 57996947,
      "verifyEd25519Signature-cpu-arguments-slope": 18975,
      "verifyEd25519Signature-memory-arguments": 10
    }).forEach((r, n) => e.set(n, i.Int.new_i32(r)));
    const t = i.CostModel.new();
    return Object.values({
      "addInteger-cpu-arguments-intercept": 205665,
      "addInteger-cpu-arguments-slope": 812,
      "addInteger-memory-arguments-intercept": 1,
      "addInteger-memory-arguments-slope": 1,
      "appendByteString-cpu-arguments-intercept": 1e3,
      "appendByteString-cpu-arguments-slope": 571,
      "appendByteString-memory-arguments-intercept": 0,
      "appendByteString-memory-arguments-slope": 1,
      "appendString-cpu-arguments-intercept": 1e3,
      "appendString-cpu-arguments-slope": 24177,
      "appendString-memory-arguments-intercept": 4,
      "appendString-memory-arguments-slope": 1,
      "bData-cpu-arguments": 1e3,
      "bData-memory-arguments": 32,
      "blake2b_256-cpu-arguments-intercept": 117366,
      "blake2b_256-cpu-arguments-slope": 10475,
      "blake2b_256-memory-arguments": 4,
      "cekApplyCost-exBudgetCPU": 23e3,
      "cekApplyCost-exBudgetMemory": 100,
      "cekBuiltinCost-exBudgetCPU": 23e3,
      "cekBuiltinCost-exBudgetMemory": 100,
      "cekConstCost-exBudgetCPU": 23e3,
      "cekConstCost-exBudgetMemory": 100,
      "cekDelayCost-exBudgetCPU": 23e3,
      "cekDelayCost-exBudgetMemory": 100,
      "cekForceCost-exBudgetCPU": 23e3,
      "cekForceCost-exBudgetMemory": 100,
      "cekLamCost-exBudgetCPU": 23e3,
      "cekLamCost-exBudgetMemory": 100,
      "cekStartupCost-exBudgetCPU": 100,
      "cekStartupCost-exBudgetMemory": 100,
      "cekVarCost-exBudgetCPU": 23e3,
      "cekVarCost-exBudgetMemory": 100,
      "chooseData-cpu-arguments": 19537,
      "chooseData-memory-arguments": 32,
      "chooseList-cpu-arguments": 175354,
      "chooseList-memory-arguments": 32,
      "chooseUnit-cpu-arguments": 46417,
      "chooseUnit-memory-arguments": 4,
      "consByteString-cpu-arguments-intercept": 221973,
      "consByteString-cpu-arguments-slope": 511,
      "consByteString-memory-arguments-intercept": 0,
      "consByteString-memory-arguments-slope": 1,
      "constrData-cpu-arguments": 89141,
      "constrData-memory-arguments": 32,
      "decodeUtf8-cpu-arguments-intercept": 497525,
      "decodeUtf8-cpu-arguments-slope": 14068,
      "decodeUtf8-memory-arguments-intercept": 4,
      "decodeUtf8-memory-arguments-slope": 2,
      "divideInteger-cpu-arguments-constant": 196500,
      "divideInteger-cpu-arguments-model-arguments-intercept": 453240,
      "divideInteger-cpu-arguments-model-arguments-slope": 220,
      "divideInteger-memory-arguments-intercept": 0,
      "divideInteger-memory-arguments-minimum": 1,
      "divideInteger-memory-arguments-slope": 1,
      "encodeUtf8-cpu-arguments-intercept": 1e3,
      "encodeUtf8-cpu-arguments-slope": 28662,
      "encodeUtf8-memory-arguments-intercept": 4,
      "encodeUtf8-memory-arguments-slope": 2,
      "equalsByteString-cpu-arguments-constant": 245e3,
      "equalsByteString-cpu-arguments-intercept": 216773,
      "equalsByteString-cpu-arguments-slope": 62,
      "equalsByteString-memory-arguments": 1,
      "equalsData-cpu-arguments-intercept": 1060367,
      "equalsData-cpu-arguments-slope": 12586,
      "equalsData-memory-arguments": 1,
      "equalsInteger-cpu-arguments-intercept": 208512,
      "equalsInteger-cpu-arguments-slope": 421,
      "equalsInteger-memory-arguments": 1,
      "equalsString-cpu-arguments-constant": 187e3,
      "equalsString-cpu-arguments-intercept": 1e3,
      "equalsString-cpu-arguments-slope": 52998,
      "equalsString-memory-arguments": 1,
      "fstPair-cpu-arguments": 80436,
      "fstPair-memory-arguments": 32,
      "headList-cpu-arguments": 43249,
      "headList-memory-arguments": 32,
      "iData-cpu-arguments": 1e3,
      "iData-memory-arguments": 32,
      "ifThenElse-cpu-arguments": 80556,
      "ifThenElse-memory-arguments": 1,
      "indexByteString-cpu-arguments": 57667,
      "indexByteString-memory-arguments": 4,
      "lengthOfByteString-cpu-arguments": 1e3,
      "lengthOfByteString-memory-arguments": 10,
      "lessThanByteString-cpu-arguments-intercept": 197145,
      "lessThanByteString-cpu-arguments-slope": 156,
      "lessThanByteString-memory-arguments": 1,
      "lessThanEqualsByteString-cpu-arguments-intercept": 197145,
      "lessThanEqualsByteString-cpu-arguments-slope": 156,
      "lessThanEqualsByteString-memory-arguments": 1,
      "lessThanEqualsInteger-cpu-arguments-intercept": 204924,
      "lessThanEqualsInteger-cpu-arguments-slope": 473,
      "lessThanEqualsInteger-memory-arguments": 1,
      "lessThanInteger-cpu-arguments-intercept": 208896,
      "lessThanInteger-cpu-arguments-slope": 511,
      "lessThanInteger-memory-arguments": 1,
      "listData-cpu-arguments": 52467,
      "listData-memory-arguments": 32,
      "mapData-cpu-arguments": 64832,
      "mapData-memory-arguments": 32,
      "mkCons-cpu-arguments": 65493,
      "mkCons-memory-arguments": 32,
      "mkNilData-cpu-arguments": 22558,
      "mkNilData-memory-arguments": 32,
      "mkNilPairData-cpu-arguments": 16563,
      "mkNilPairData-memory-arguments": 32,
      "mkPairData-cpu-arguments": 76511,
      "mkPairData-memory-arguments": 32,
      "modInteger-cpu-arguments-constant": 196500,
      "modInteger-cpu-arguments-model-arguments-intercept": 453240,
      "modInteger-cpu-arguments-model-arguments-slope": 220,
      "modInteger-memory-arguments-intercept": 0,
      "modInteger-memory-arguments-minimum": 1,
      "modInteger-memory-arguments-slope": 1,
      "multiplyInteger-cpu-arguments-intercept": 69522,
      "multiplyInteger-cpu-arguments-slope": 11687,
      "multiplyInteger-memory-arguments-intercept": 0,
      "multiplyInteger-memory-arguments-slope": 1,
      "nullList-cpu-arguments": 60091,
      "nullList-memory-arguments": 32,
      "quotientInteger-cpu-arguments-constant": 196500,
      "quotientInteger-cpu-arguments-model-arguments-intercept": 453240,
      "quotientInteger-cpu-arguments-model-arguments-slope": 220,
      "quotientInteger-memory-arguments-intercept": 0,
      "quotientInteger-memory-arguments-minimum": 1,
      "quotientInteger-memory-arguments-slope": 1,
      "remainderInteger-cpu-arguments-constant": 196500,
      "remainderInteger-cpu-arguments-model-arguments-intercept": 453240,
      "remainderInteger-cpu-arguments-model-arguments-slope": 220,
      "remainderInteger-memory-arguments-intercept": 0,
      "remainderInteger-memory-arguments-minimum": 1,
      "remainderInteger-memory-arguments-slope": 1,
      "serialiseData-cpu-arguments-intercept": 1159724,
      "serialiseData-cpu-arguments-slope": 392670,
      "serialiseData-memory-arguments-intercept": 0,
      "serialiseData-memory-arguments-slope": 2,
      "sha2_256-cpu-arguments-intercept": 806990,
      "sha2_256-cpu-arguments-slope": 30482,
      "sha2_256-memory-arguments": 4,
      "sha3_256-cpu-arguments-intercept": 1927926,
      "sha3_256-cpu-arguments-slope": 82523,
      "sha3_256-memory-arguments": 4,
      "sliceByteString-cpu-arguments-intercept": 265318,
      "sliceByteString-cpu-arguments-slope": 0,
      "sliceByteString-memory-arguments-intercept": 4,
      "sliceByteString-memory-arguments-slope": 0,
      "sndPair-cpu-arguments": 85931,
      "sndPair-memory-arguments": 32,
      "subtractInteger-cpu-arguments-intercept": 205665,
      "subtractInteger-cpu-arguments-slope": 812,
      "subtractInteger-memory-arguments-intercept": 1,
      "subtractInteger-memory-arguments-slope": 1,
      "tailList-cpu-arguments": 41182,
      "tailList-memory-arguments": 32,
      "trace-cpu-arguments": 212342,
      "trace-memory-arguments": 32,
      "unBData-cpu-arguments": 31220,
      "unBData-memory-arguments": 32,
      "unConstrData-cpu-arguments": 32696,
      "unConstrData-memory-arguments": 32,
      "unIData-cpu-arguments": 43357,
      "unIData-memory-arguments": 32,
      "unListData-cpu-arguments": 32247,
      "unListData-memory-arguments": 32,
      "unMapData-cpu-arguments": 38314,
      "unMapData-memory-arguments": 32,
      "verifyEcdsaSecp256k1Signature-cpu-arguments": 35892428,
      "verifyEcdsaSecp256k1Signature-memory-arguments": 10,
      "verifyEd25519Signature-cpu-arguments-intercept": 57996947,
      "verifyEd25519Signature-cpu-arguments-slope": 18975,
      "verifyEd25519Signature-memory-arguments": 10,
      "verifySchnorrSecp256k1Signature-cpu-arguments-intercept": 38887044,
      "verifySchnorrSecp256k1Signature-cpu-arguments-slope": 32947,
      "verifySchnorrSecp256k1Signature-memory-arguments": 10
    }).forEach((r, n) => t.set(n, i.Int.new_i32(r))), s.insert(i.Language.new_plutus_v1(), e), s.insert(i.Language.new_plutus_v2(), t), s;
  })()
}, Zr = {
  ALONZO: {
    V1: "a141005901d59f1a000302590001011a00060bc719026d00011a000249f01903e800011a000249f018201a0025cea81971f70419744d186419744d186419744d186419744d186419744d186419744d18641864186419744d18641a000249f018201a000249f018201a000249f018201a000249f01903e800011a000249f018201a000249f01903e800081a000242201a00067e2318760001011a000249f01903e800081a000249f01a0001b79818f7011a000249f0192710011a0002155e19052e011903e81a000249f01903e8011a000249f018201a000249f018201a000249f0182001011a000249f0011a000249f0041a000194af18f8011a000194af18f8011a0002377c190556011a0002bdea1901f1011a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000242201a00067e23187600010119f04c192bd200011a000249f018201a000242201a00067e2318760001011a000242201a00067e2318760001011a0025cea81971f704001a000141bb041a000249f019138800011a000249f018201a000302590001011a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a00330da70101ff"
  },
  BABBAGE: {
    V1: "a141005901b69f1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a009063b91903fd0aff",
    V2: "a20198af1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a0011b22c1a0005fdde00021a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201b00000004a817c8001b00000004a817c8001a009063b91903fd0a1b00000004a817c800001b00000004a817c80041005901b69f1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a009063b91903fd0aff"
  }
}, Fe = {
  [i.NetworkInfo.testnet().network_id()]: "8d18d786e92776c824607fd8e193ec535c79dc61ea2405ddf3b09fe3",
  [i.NetworkInfo.mainnet().network_id()]: "f0ff48bbb7bbe9d59a40f1ce90e9e9d0ff5002ec48f232b49ca0fb9a"
}, ts = {
  mainnet: "wss://ogmios-api.mainnet.dandelion.link",
  preprod: "wss://ogmios-api.iohk-preprod.dandelion.link",
  preview: "__TBD_SOON_TM__",
  testnet: "wss://ogmios-api.testnet.dandelion.link"
}, es = {
  LQ: "da8c30857834c6ae7203935b89278c532b3995245295456f993e1d244c51",
  MIN: "29d222ce763455e3d7a09a665ce554f00ac89d2e99a1a83d267170c64d494e",
  NTX: "edfd7a1d77bcb8b884c474bdc92a16002d1fb720e454fa6e993444794e5458",
  iBTC: "f66d78b4a3cb3d37afa0ec36461e51ecbde00f26c8f0a68f94b6988069425443",
  iETH: "f66d78b4a3cb3d37afa0ec36461e51ecbde00f26c8f0a68f94b6988069455448",
  iUSD: "f66d78b4a3cb3d37afa0ec36461e51ecbde00f26c8f0a68f94b6988069555344",
  MILK: "8a1cfae21368b8bebbbed9800fec304e95cce39a2a57dc35e2e3ebaa4d494c4b",
  AGIX: "f43a62fdc3965df486de8a0d32fe800963589c41b38946602a0dc53541474958",
  MELD: "6ac8ef33b510ec004fe11585f7c5a9f0c07f0c23428ab4f29c1d7d104d454c44",
  INDY: "533bb94a8850ee3ccbe483106489399112b74c905342cb1792a797a0494e4459",
  CLAY: "38ad9dc3aec6a2f38e220142b9aa6ade63ebe71f65e7cc2b7d8a8535434c4159",
  MCOS: "6f46e1304b16d884c85c62fb0eef35028facdc41aaa0fd319a152ed64d434f53",
  DING: "ce5b9e0f8a88255b65f2e4d065c6e716e9fa9a8a86dfb86423dd1ac044494e47",
  GERO: "10a49b996e2402269af553a8a96fb8eb90d79e9eca79e2b4223057b64745524f",
  NMKR: "5dac8536653edc12f6f5e1045d8164b9f59998d3bdc300fc928434894e4d4b52",
  PAVIA: "884892bcdc360bcef87d6b3f806e7f9cd5ac30d999d49970e7a903ae5041564941",
  HOSKY: "a0028f350aaabe0545fdcb56b039bfb08e4bb4d8c4d7c3c7d481c235484f534b59",
  YUMMI: "078eafce5cd7edafdf63900edef2c1ea759e77f30ca81d6bbdeec92479756d6d69",
  C3: "8e51398904a5d3fc129fbf4f1589701de23c7824d5c90fdb9490e15a434841524c4933",
  GIMBAL: "2b0a04a7b60132b1805b296c7fcb3b217ff14413991bf76f72663c3067696d62616c",
  SUNDAE: "9a9693a9a37912a5097918f97918d15240c92ab729a0b7c4aa144d7753554e444145",
  GREENS: "4623ab311b7d982d8d26fcbe1a9439ca56661aafcdcd8d8a0ef31fd6475245454e53",
  GENS: "dda5fdb1002f7389b33e036b6afee82a8189becb6cba852e8b79b4fb0014df1047454e53",
  SOCIETY: "25f0fc240e91bd95dcdaebd2ba7713fc5168ac77234a3d79449fc20c534f4349455459",
  DJED: "8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd61446a65644d6963726f555344",
  SHEN: "8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd615368656e4d6963726f555344",
  WMT: "1d7f33bd23d85e1a25d87d86fac4f199c3197a2f7afeb662a0f34e1e776f726c646d6f62696c65746f6b656e",
  COPI: "b6a7467ea1deb012808ef4e87b5ff371e85f7142d7b356a40d9b42a0436f726e75636f70696173205b76696120436861696e506f72742e696f5d"
}, We = [
  "begin",
  "eternl",
  "flint",
  "lace",
  "nami",
  "nufi",
  "gerowallet",
  "typhoncip30",
  "vespr",
  "yoroi"
], rs = (s, e, t = "5000000") => {
  const r = i.BigNum.from_str(s.get("lovelace") ?? "0").checked_add(i.BigNum.from_str(t)), n = e.filter((l) => l.output.amount.filter((p) => p.unit !== "lovelace").some((p) => s.has(p.unit))), a = as(n);
  return [
    ...a.less_than(r) ? os(r.clamped_sub(a).to_str(), e.filter((l) => !n.some((p) => p.input.txHash === l.input.txHash && p.input.outputIndex === l.input.outputIndex))) : [],
    ...n
  ];
}, nn = (s, e, t = !1, { maxTxSize: r, minFeeA: n, minFeeB: a } = ft) => {
  const c = e.filter((E) => wr(E) === !1).sort(Re), l = i.BigNum.from_str(Fr(r, n, a)), p = t ? i.BigNum.from_str(s).checked_add(l).to_str() : s;
  return ne(c, /* @__PURE__ */ new Map([
    ["lovelace", p]
  ]));
}, ss = (s, e, t = !1, r = ft) => {
  const n = e.filter(wr).sort(Re), a = is(r), c = s.get("lovelace") ?? "0", l = t ? i.BigNum.from_str(c).checked_add(a).to_str() : c;
  return s.set("lovelace", l), ne(n, s);
}, ns = (s, e) => Array.from(e, (t) => ({ unit: t[0], quantity: i.BigNum.from_str(t[1]) })).every((t) => s.filter((r) => r.output.amount.find((n) => n.unit === t.unit) !== void 0).reduce((r, n) => {
  const a = n.output.amount.reduce((c, l) => c.checked_add(i.BigNum.from_str(t.unit === l.unit ? l.quantity : "0")), i.BigNum.from_str("0"));
  return r.checked_add(a);
}, i.BigNum.from_str("0")).less_than(t.quantity) === !1), Re = (s, e) => {
  var n, a;
  const t = i.BigNum.from_str(((n = s.output.amount.find((c) => c.unit === "lovelace")) == null ? void 0 : n.quantity) ?? "0");
  return i.BigNum.from_str(((a = e.output.amount.find((c) => c.unit === "lovelace")) == null ? void 0 : a.quantity) ?? "0").compare(t);
}, is = (s) => {
  const { maxTxSize: e, minFeeA: t, minFeeB: r } = s;
  return i.BigNum.from_str(Fr(e, t, r));
}, wr = (s) => s.output.amount.length > 1, as = (s) => s.reduce((e, t) => {
  var n;
  const r = ((n = t.output.amount.find((a) => a.unit === "lovelace")) == null ? void 0 : n.quantity) ?? "0";
  return e.checked_add(i.BigNum.from_str(r));
}, i.BigNum.from_str("0")), os = (s, e) => {
  const t = e.sort(Re);
  return ne(t, /* @__PURE__ */ new Map([
    ["lovelace", s]
  ]));
}, ne = (s, e, t = []) => s.length === 0 || ns(t, e) ? t : cs(s[0], e) ? ne(s.slice(1), e, [...t, s[0]]) : ne(s.slice(1), e, t), cs = (s, e) => Array.from(e.keys()).some((t) => s.output.amount.find((r) => r.unit === t) !== void 0), us = (s, e) => {
  const t = hs(e), r = ds(s, e);
  return {
    coseKey: lt(t.to_bytes()),
    coseSign1: lt(r.to_bytes())
  };
}, an = (s, e, { key: t, signature: r }) => {
  var c, l;
  const n = yr.from_bytes(G(t)), a = Gr.from_bytes(G(r));
  if ((s == null ? void 0 : s.length) > 0) {
    const p = lt(a.payload() ?? new Uint8Array());
    if (ot(s) !== p)
      return !1;
  }
  if ((e == null ? void 0 : e.length) > 0) {
    const A = (c = a.headers().protected().deserialized_headers().header(Ut.new_text("address"))) == null ? void 0 : c.as_bytes();
    if (A === void 0)
      throw new Error("Couldn't find a signer address in signature");
    const C = (l = n.header(Ut.new_int(de.new_negative(ke.from_str("2"))))) == null ? void 0 : l.as_bytes();
    if (C === void 0)
      throw new Error("Couldn't find a signer key in signature");
    const E = Lt(lt(A)), w = Ks(lt(C));
    if (ls(e, E, w) === !1)
      throw new Error("Couldn't check signature because of address mismatch");
    const b = Ms(lt(a.signature())), P = a.signed_data().to_bytes();
    return w.verify(P, b);
  }
  return !1;
}, ls = (s, e, t) => {
  if (s !== e.to_bech32())
    return !1;
  try {
    return re(s) === t.hash().to_hex();
  } catch {
    return !1;
  }
}, hs = (s) => {
  const e = yr.new(Ut.from_key_type(Yr.OKP));
  return e.set_algorithm_id(Ut.from_algorithm_id(xr.EdDSA)), e.set_header(Ut.new_int(de.new_negative(ke.from_str("1"))), Te.new_int(de.new_i32(6))), e.set_header(Ut.new_int(de.new_negative(ke.from_str("2"))), Te.new_bytes(s.key.to_public().as_bytes())), e;
}, ds = (s, e) => {
  const t = ze.new(), r = ze.new();
  t.set_algorithm_id(Ut.from_algorithm_id(xr.EdDSA)), t.set_header(Ut.new_text("address"), Te.new_bytes(e.address.to_bytes()));
  const n = $r.new(zr.new(t), r), a = Jr.new(n, G(s.payload), !1);
  s.externalAAD !== void 0 && a.set_external_aad(G(s.externalAAD));
  const c = a.make_data_to_sign(), l = e.key.sign(c.to_bytes());
  return a.build(l.to_bytes());
};
var Ne = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Cr = {}, ct = { exports: {} };
Qt.notEqual = gs;
Qt.notOk = ms;
Qt.equal = fs;
Qt.ok = Qt;
var Br = Qt;
function fs(s, e, t) {
  Qt(s == e, t);
}
function gs(s, e, t) {
  Qt(s != e, t);
}
function ms(s, e) {
  Qt(!s, e);
}
function Qt(s, e) {
  if (!s)
    throw new Error(e || "AssertionError");
}
var Bt = { exports: {} };
function As(s) {
  throw new Error('Could not dynamically require "' + s + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ps = qe;
qe.supported = typeof WebAssembly < "u";
function qe(s) {
  if (!qe.supported)
    return null;
  var e = s && s.imports, t = Is("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0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"), r = null, n = {
    buffer: t,
    memory: null,
    exports: null,
    realloc: a,
    onload: c
  };
  return c(function() {
  }), n;
  function a(p) {
    n.exports.memory.grow(Math.ceil(Math.abs(p - n.memory.length) / 65536)), n.memory = new Uint8Array(n.exports.memory.buffer);
  }
  function c(p) {
    if (n.exports)
      return p();
    if (r) {
      r.then(p.bind(null, null)).catch(p);
      return;
    }
    try {
      if (s && s.async)
        throw new Error("async");
      l({ instance: new WebAssembly.Instance(new WebAssembly.Module(t), e) });
    } catch {
      r = WebAssembly.instantiate(t, e).then(l);
    }
    c(p);
  }
  function l(p) {
    n.exports = p.instance.exports, n.memory = n.exports.memory && n.exports.memory.buffer && new Uint8Array(n.exports.memory.buffer);
  }
}
function Is(s) {
  return typeof atob == "function" ? new Uint8Array(atob(s).split("").map(_s)) : new (As("buffer")).Buffer(s, "base64");
}
function _s(s) {
  return s.charCodeAt(0);
}
var yt = Br, J = ps(), vt = 64, fe = [];
Bt.exports = gt;
var je = Bt.exports.BYTES_MIN = 16, Xe = Bt.exports.BYTES_MAX = 64;
Bt.exports.BYTES = 32;
var Ze = Bt.exports.KEYBYTES_MIN = 16, tr = Bt.exports.KEYBYTES_MAX = 64;
Bt.exports.KEYBYTES = 32;
var er = Bt.exports.SALTBYTES = 16, rr = Bt.exports.PERSONALBYTES = 16;
function gt(s, e, t, r, n) {
  if (!(this instanceof gt))
    return new gt(s, e, t, r, n);
  if (!(J && J.exports))
    throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
  s || (s = 32), n !== !0 && (yt(s >= je, "digestLength must be at least " + je + ", was given " + s), yt(s <= Xe, "digestLength must be at most " + Xe + ", was given " + s), e != null && yt(e.length >= Ze, "key must be at least " + Ze + ", was given " + e.length), e != null && yt(e.length <= tr, "key must be at least " + tr + ", was given " + e.length), t != null && yt(t.length === er, "salt must be exactly " + er + ", was given " + t.length), r != null && yt(r.length === rr, "personal must be exactly " + rr + ", was given " + r.length)), fe.length || (fe.push(vt), vt += 216), this.digestLength = s, this.finalized = !1, this.pointer = fe.pop(), J.memory.fill(0, 0, 64), J.memory[0] = this.digestLength, J.memory[1] = e ? e.length : 0, J.memory[2] = 1, J.memory[3] = 1, t && J.memory.set(t, 32), r && J.memory.set(r, 48), this.pointer + 216 > J.memory.length && J.realloc(this.pointer + 216), J.exports.blake2b_init(this.pointer, this.digestLength), e && (this.update(e), J.memory.fill(0, vt, vt + e.length), J.memory[this.pointer + 200] = 128);
}
gt.prototype.update = function(s) {
  return yt(this.finalized === !1, "Hash instance finalized"), yt(s, "input must be TypedArray or Buffer"), vt + s.length > J.memory.length && J.realloc(vt + s.length), J.memory.set(s, vt), J.exports.blake2b_update(this.pointer, vt, vt + s.length), this;
};
gt.prototype.digest = function(s) {
  if (yt(this.finalized === !1, "Hash instance finalized"), this.finalized = !0, fe.push(this.pointer), J.exports.blake2b_final(this.pointer), !s || s === "binary")
    return J.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
  if (s === "hex")
    return xs(J.memory, this.pointer + 128, this.digestLength);
  yt(s.length >= this.digestLength, "input must be TypedArray or Buffer");
  for (var e = 0; e < this.digestLength; e++)
    s[e] = J.memory[this.pointer + 128 + e];
  return s;
};
gt.prototype.final = gt.prototype.digest;
gt.WASM = J && J.buffer;
gt.SUPPORTED = typeof WebAssembly < "u";
gt.ready = function(s) {
  if (s || (s = ys), !J)
    return s(new Error("WebAssembly not supported"));
  var e = new Promise(function(t, r) {
    J.onload(function(n) {
      n ? r() : t(), s(n);
    });
  });
  return e;
};
gt.prototype.ready = gt.ready;
function ys() {
}
function xs(s, e, t) {
  for (var r = "", n = 0; n < t; n++)
    r += ws(s[e + n]);
  return r;
}
function ws(s) {
  return s < 16 ? "0" + s.toString(16) : s.toString(16);
}
var Pt = Br, ie = Bt.exports;
function oe(s, e, t) {
  var r = s[e] + s[t], n = s[e + 1] + s[t + 1];
  r >= 4294967296 && n++, s[e] = r, s[e + 1] = n;
}
function sr(s, e, t, r) {
  var n = s[e] + t;
  t < 0 && (n += 4294967296);
  var a = s[e + 1] + r;
  n >= 4294967296 && a++, s[e] = n, s[e + 1] = a;
}
function Er(s, e) {
  return s[e] ^ s[e + 1] << 8 ^ s[e + 2] << 16 ^ s[e + 3] << 24;
}
function Tt(s, e, t, r, n, a) {
  var c = ee[n], l = ee[n + 1], p = ee[a], A = ee[a + 1];
  oe(H, s, e), sr(H, s, c, l);
  var C = H[r] ^ H[s], E = H[r + 1] ^ H[s + 1];
  H[r] = E, H[r + 1] = C, oe(H, t, r), C = H[e] ^ H[t], E = H[e + 1] ^ H[t + 1], H[e] = C >>> 24 ^ E << 8, H[e + 1] = E >>> 24 ^ C << 8, oe(H, s, e), sr(H, s, p, A), C = H[r] ^ H[s], E = H[r + 1] ^ H[s + 1], H[r] = C >>> 16 ^ E << 16, H[r + 1] = E >>> 16 ^ C << 16, oe(H, t, r), C = H[e] ^ H[t], E = H[e + 1] ^ H[t + 1], H[e] = E >>> 31 ^ C << 1, H[e + 1] = C >>> 31 ^ E << 1;
}
var Sr = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), Cs = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
], it = new Uint8Array(Cs.map(function(s) {
  return s * 2;
})), H = new Uint32Array(32), ee = new Uint32Array(32);
function vr(s, e) {
  var t = 0;
  for (t = 0; t < 16; t++)
    H[t] = s.h[t], H[t + 16] = Sr[t];
  for (H[24] = H[24] ^ s.t, H[25] = H[25] ^ s.t / 4294967296, e && (H[28] = ~H[28], H[29] = ~H[29]), t = 0; t < 32; t++)
    ee[t] = Er(s.b, 4 * t);
  for (t = 0; t < 12; t++)
    Tt(0, 8, 16, 24, it[t * 16 + 0], it[t * 16 + 1]), Tt(2, 10, 18, 26, it[t * 16 + 2], it[t * 16 + 3]), Tt(4, 12, 20, 28, it[t * 16 + 4], it[t * 16 + 5]), Tt(6, 14, 22, 30, it[t * 16 + 6], it[t * 16 + 7]), Tt(0, 10, 20, 30, it[t * 16 + 8], it[t * 16 + 9]), Tt(2, 12, 22, 24, it[t * 16 + 10], it[t * 16 + 11]), Tt(4, 14, 16, 26, it[t * 16 + 12], it[t * 16 + 13]), Tt(6, 8, 18, 28, it[t * 16 + 14], it[t * 16 + 15]);
  for (t = 0; t < 16; t++)
    s.h[t] = s.h[t] ^ H[t] ^ H[t + 16];
}
var Nt = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function Jt(s, e, t, r) {
  Nt.fill(0), this.b = new Uint8Array(128), this.h = new Uint32Array(16), this.t = 0, this.c = 0, this.outlen = s, Nt[0] = s, e && (Nt[1] = e.length), Nt[2] = 1, Nt[3] = 1, t && Nt.set(t, 32), r && Nt.set(r, 48);
  for (var n = 0; n < 16; n++)
    this.h[n] = Sr[n] ^ Er(Nt, n * 4);
  e && (br(this, e), this.c = 128);
}
Jt.prototype.update = function(s) {
  return Pt(s != null, "input must be Uint8Array or Buffer"), br(this, s), this;
};
Jt.prototype.digest = function(s) {
  var e = !s || s === "binary" || s === "hex" ? new Uint8Array(this.outlen) : s;
  return Pt(e.length >= this.outlen, "out must have at least outlen bytes of space"), Bs(this, e), s === "hex" ? Es(e) : e;
};
Jt.prototype.final = Jt.prototype.digest;
Jt.ready = function(s) {
  ie.ready(function() {
    s();
  });
};
function br(s, e) {
  for (var t = 0; t < e.length; t++)
    s.c === 128 && (s.t += s.c, vr(s, !1), s.c = 0), s.b[s.c++] = e[t];
}
function Bs(s, e) {
  for (s.t += s.c; s.c < 128; )
    s.b[s.c++] = 0;
  vr(s, !0);
  for (var t = 0; t < s.outlen; t++)
    e[t] = s.h[t >> 2] >> 8 * (t & 3);
  return e;
}
function Es(s) {
  for (var e = "", t = 0; t < s.length; t++)
    e += Ss(s[t]);
  return e;
}
function Ss(s) {
  return s < 16 ? "0" + s.toString(16) : s.toString(16);
}
var Qr = Jt;
ct.exports = function(e, t, r, n, a) {
  return a !== !0 && (Pt(e >= nr, "outlen must be at least " + nr + ", was given " + e), Pt(e <= ir, "outlen must be at most " + ir + ", was given " + e), t != null && Pt(t.length >= ar, "key must be at least " + ar + ", was given " + t.length), t != null && Pt(t.length <= or, "key must be at most " + or + ", was given " + t.length), r != null && Pt(r.length === cr, "salt must be exactly " + cr + ", was given " + r.length), n != null && Pt(n.length === ur, "personal must be exactly " + ur + ", was given " + n.length)), new Qr(e, t, r, n);
};
ct.exports.ready = function(s) {
  ie.ready(function() {
    s();
  });
};
ct.exports.WASM_SUPPORTED = ie.SUPPORTED;
ct.exports.WASM_LOADED = !1;
var nr = ct.exports.BYTES_MIN = 16, ir = ct.exports.BYTES_MAX = 64;
ct.exports.BYTES = 32;
var ar = ct.exports.KEYBYTES_MIN = 16, or = ct.exports.KEYBYTES_MAX = 64;
ct.exports.KEYBYTES = 32;
var cr = ct.exports.SALTBYTES = 16, ur = ct.exports.PERSONALBYTES = 16;
ie.ready(function(s) {
  s || (ct.exports.WASM_LOADED = !0, Qr = ie);
});
var Wt = {};
Object.defineProperty(Wt, "__esModule", { value: !0 });
Wt.bech32m = Wt.bech32 = void 0;
const pe = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Dr = {};
for (let s = 0; s < pe.length; s++) {
  const e = pe.charAt(s);
  Dr[e] = s;
}
function $t(s) {
  const e = s >> 25;
  return (s & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059;
}
function lr(s) {
  let e = 1;
  for (let t = 0; t < s.length; ++t) {
    const r = s.charCodeAt(t);
    if (r < 33 || r > 126)
      return "Invalid prefix (" + s + ")";
    e = $t(e) ^ r >> 5;
  }
  e = $t(e);
  for (let t = 0; t < s.length; ++t) {
    const r = s.charCodeAt(t);
    e = $t(e) ^ r & 31;
  }
  return e;
}
function Ve(s, e, t, r) {
  let n = 0, a = 0;
  const c = (1 << t) - 1, l = [];
  for (let p = 0; p < s.length; ++p)
    for (n = n << e | s[p], a += e; a >= t; )
      a -= t, l.push(n >> a & c);
  if (r)
    a > 0 && l.push(n << t - a & c);
  else {
    if (a >= e)
      return "Excess padding";
    if (n << t - a & c)
      return "Non-zero padding";
  }
  return l;
}
function vs(s) {
  return Ve(s, 8, 5, !0);
}
function bs(s) {
  const e = Ve(s, 5, 8, !1);
  if (Array.isArray(e))
    return e;
}
function Qs(s) {
  const e = Ve(s, 5, 8, !1);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
function kr(s) {
  let e;
  s === "bech32" ? e = 1 : e = 734539939;
  function t(c, l, p) {
    if (p = p || 90, c.length + 7 + l.length > p)
      throw new TypeError("Exceeds length limit");
    c = c.toLowerCase();
    let A = lr(c);
    if (typeof A == "string")
      throw new Error(A);
    let C = c + "1";
    for (let E = 0; E < l.length; ++E) {
      const w = l[E];
      if (w >> 5 !== 0)
        throw new Error("Non 5-bit word");
      A = $t(A) ^ w, C += pe.charAt(w);
    }
    for (let E = 0; E < 6; ++E)
      A = $t(A);
    A ^= e;
    for (let E = 0; E < 6; ++E) {
      const w = A >> (5 - E) * 5 & 31;
      C += pe.charAt(w);
    }
    return C;
  }
  function r(c, l) {
    if (l = l || 90, c.length < 8)
      return c + " too short";
    if (c.length > l)
      return "Exceeds length limit";
    const p = c.toLowerCase(), A = c.toUpperCase();
    if (c !== p && c !== A)
      return "Mixed-case string " + c;
    c = p;
    const C = c.lastIndexOf("1");
    if (C === -1)
      return "No separator character for " + c;
    if (C === 0)
      return "Missing prefix for " + c;
    const E = c.slice(0, C), w = c.slice(C + 1);
    if (w.length < 6)
      return "Data too short";
    let b = lr(E);
    if (typeof b == "string")
      return b;
    const P = [];
    for (let k = 0; k < w.length; ++k) {
      const N = w.charAt(k), T = Dr[N];
      if (T === void 0)
        return "Unknown character " + N;
      b = $t(b) ^ T, !(k + 6 >= w.length) && P.push(T);
    }
    return b !== e ? "Invalid checksum for " + c : { prefix: E, words: P };
  }
  function n(c, l) {
    const p = r(c, l);
    if (typeof p == "object")
      return p;
  }
  function a(c, l) {
    const p = r(c, l);
    if (typeof p == "object")
      return p;
    throw new Error(p);
  }
  return {
    decodeUnsafe: n,
    decode: a,
    encode: t,
    toWords: vs,
    fromWordsUnsafe: bs,
    fromWords: Qs
  };
}
Wt.bech32 = kr("bech32");
Wt.bech32m = kr("bech32m");
var Ds = Ne && Ne.__importDefault || function(s) {
  return s && s.__esModule ? s : { default: s };
};
Object.defineProperty(Cr, "__esModule", { value: !0 });
const ks = Ds(ct.exports), ce = Wt, De = "asset";
class se {
  constructor(e) {
    this.hashBuf = e;
  }
  static fromHash(e) {
    return new se(e);
  }
  static fromParts(e, t) {
    const r = (0, ks.default)(20).update(new Uint8Array([...e, ...t])).digest("binary");
    return se.fromHash(r);
  }
  static fromBech32(e) {
    const { prefix: t, words: r } = ce.bech32.decode(e);
    if (t !== De)
      throw new Error("Invalid asset fingerprint");
    const n = Buffer.from(ce.bech32.fromWords(r));
    return se.fromHash(n);
  }
  fingerprint() {
    const e = ce.bech32.toWords(this.hashBuf);
    return ce.bech32.encode(De, e);
  }
  hash() {
    return Buffer.from(this.hashBuf).toString("hex");
  }
  prefix() {
    return De;
  }
  checksum() {
    return this.fingerprint().slice(-6);
  }
}
var Ts = Cr.default = se;
const Ns = Ts, Ps = (s, e) => {
  const t = Us(s), r = t.derive(Qe + 1852).derive(Qe + 1815).derive(Qe + e), n = r.derive(0).derive(0).to_raw_key(), a = r.derive(2).derive(0).to_raw_key();
  return r.free(), t.free(), { paymentKey: n, stakeKey: a };
}, Lt = (s) => i.Address.from_bytes(G(s)), Us = (s) => i.Bip32PrivateKey.from_bytes(G(s)), Os = (s) => i.DataHash.from_bytes(G(s)), wt = (s) => i.Ed25519KeyHash.from_bytes(G(s)), Ms = (s) => i.Ed25519Signature.from_bytes(G(s)), _e = (s) => i.NativeScript.from_bytes(G(s)), Ks = (s) => i.PublicKey.from_bytes(G(s)), Tr = (s) => i.PlutusData.from_bytes(G(s)), jt = (s, e) => i.PlutusScript.from_bytes_with_version(G(s), St[e]), Hs = (s) => i.ScriptRef.from_bytes(G(s)), Fs = (s) => i.ScriptHash.from_bytes(G(s)), pt = (s) => i.Transaction.from_bytes(G(s)), Nr = (s) => i.TransactionHash.from_bytes(G(s)), hr = (s) => i.TransactionUnspentOutput.from_bytes(G(s)), dr = (s) => i.TransactionWitnessSet.from_bytes(G(s)), Rs = (s) => i.Value.from_bytes(G(s)), It = (s) => i.Address.from_bech32(s), Le = (s) => i.BaseAddress.from_address(It(s)), Pr = (s) => i.EnterpriseAddress.from_address(It(s)), Ur = (s) => i.RewardAddress.from_address(It(s)), lt = (s) => Buffer.from(s).toString("hex"), G = (s) => s.length % 2 === 0 && /^[0-9A-F]*$/i.test(s) ? Buffer.from(s, "hex") : Buffer.from(s, "utf-8"), ye = (s) => {
  const e = (t) => {
    const r = new Array();
    for (let n = 0; n < t.len(); n += 1)
      r.push(ye(t.get(n)));
    return r;
  };
  switch (s.kind()) {
    case i.NativeScriptKind.ScriptAll: {
      const t = s.as_script_all();
      return {
        type: "all",
        scripts: e(t.native_scripts())
      };
    }
    case i.NativeScriptKind.ScriptAny: {
      const t = s.as_script_any();
      return {
        type: "any",
        scripts: e(t.native_scripts())
      };
    }
    case i.NativeScriptKind.ScriptNOfK: {
      const t = s.as_script_n_of_k();
      return {
        type: "atLeast",
        required: t.n(),
        scripts: e(t.native_scripts())
      };
    }
    case i.NativeScriptKind.TimelockStart:
      return {
        type: "after",
        slot: s.as_timelock_start().slot_bignum().to_str()
      };
    case i.NativeScriptKind.TimelockExpiry:
      return {
        type: "before",
        slot: s.as_timelock_expiry().slot_bignum().to_str()
      };
    case i.NativeScriptKind.ScriptPubkey:
      return {
        type: "sig",
        keyHash: s.as_script_pubkey().addr_keyhash().to_hex()
      };
    default:
      throw new Error(`Script Kind: ${s.kind()}, is not supported`);
  }
}, xe = (s) => {
  const e = (t) => {
    const r = i.NativeScripts.new();
    return t.forEach((n) => {
      r.add(xe(n));
    }), r;
  };
  switch (s.type) {
    case "all":
      return i.NativeScript.new_script_all(i.ScriptAll.new(e(s.scripts)));
    case "any":
      return i.NativeScript.new_script_any(i.ScriptAny.new(e(s.scripts)));
    case "atLeast":
      return i.NativeScript.new_script_n_of_k(i.ScriptNOfK.new(s.required, e(s.scripts)));
    case "after":
      return i.NativeScript.new_timelock_start(i.TimelockStart.new_timelockstart(i.BigNum.from_str(s.slot)));
    case "before":
      return i.NativeScript.new_timelock_expiry(i.TimelockExpiry.new_timelockexpiry(i.BigNum.from_str(s.slot)));
    case "sig":
      return i.NativeScript.new_script_pubkey(i.ScriptPubkey.new(wt(s.keyHash)));
  }
}, ge = (s) => {
  var r, n, a;
  const e = (c) => {
    const l = [];
    for (let p = 0; p < c.len(); p += 1)
      l.push(ge(c.get(p)));
    return l;
  }, t = (c) => {
    const l = /* @__PURE__ */ new Map();
    for (let p = 0; p < c.len(); p += 1) {
      const A = c.keys().get(p), C = c.get(A) ?? i.PlutusData.from_hex(ot("NO_ITEM_FOUND_INSIDE_GOLD_ROOM"));
      l.set(ge(A), ge(C));
    }
    return l;
  };
  switch (s.kind()) {
    case i.PlutusDataKind.Bytes:
      return lt(s.as_bytes() ?? new Uint8Array());
    case i.PlutusDataKind.Integer:
      return parseInt(((r = s.as_integer()) == null ? void 0 : r.to_str()) ?? "0", 10);
    case i.PlutusDataKind.List:
      return e(s.as_list() ?? i.PlutusList.new());
    case i.PlutusDataKind.Map:
      return t(s.as_map() ?? i.PlutusMap.new());
    case i.PlutusDataKind.ConstrPlutusData:
      return {
        alternative: parseInt(((n = s.as_constr_plutus_data()) == null ? void 0 : n.alternative().to_str()) ?? "0", 10),
        fields: e(((a = s.as_constr_plutus_data()) == null ? void 0 : a.data()) ?? i.PlutusList.new())
      };
    default:
      throw new Error(`PlutusData Kind: ${s.kind()}, is not supported`);
  }
}, Ot = (s) => {
  const e = (t) => {
    const r = i.PlutusList.new();
    return t.forEach((n) => {
      r.add(Ot(n));
    }), r;
  };
  switch (typeof s) {
    case "string":
      return i.PlutusData.new_bytes(G(s));
    case "number":
      return i.PlutusData.new_integer(i.BigInt.from_str(s.toString()));
    case "bigint":
      return i.PlutusData.new_integer(i.BigInt.from_str(s.toString()));
    case "object":
      if (s instanceof Array) {
        const t = e(s);
        return i.PlutusData.new_list(t);
      } else if (s instanceof Map) {
        const t = i.PlutusMap.new();
        return s.forEach((r, n) => {
          t.insert(Ot(n), Ot(r));
        }), i.PlutusData.new_map(t);
      } else
        return i.PlutusData.new_constr_plutus_data(i.ConstrPlutusData.new(i.BigNum.from_str(s.alternative.toString()), e(s.fields)));
  }
}, qs = (s) => {
  const e = i.Relays.new();
  throw s.relays.forEach((t) => {
    e.add(Or(t));
  }), new Error("toPoolParams not implemented.");
}, Pe = (s) => {
  const e = (t) => Xr[t];
  return i.Redeemer.new(e(s.tag), i.BigNum.from_str(s.index.toString()), Ot(s.data), i.ExUnits.new(i.BigNum.from_str(s.budget.mem.toString()), i.BigNum.from_str(s.budget.steps.toString())));
}, Or = (s) => {
  switch (s.type) {
    case "SingleHostAddr": {
      const e = s.IPV4 ? i.Ipv4.new(new Uint8Array(s.IPV4.split(".").map((r) => parseInt(r)))) : void 0, t = s.IPV6 ? i.Ipv6.new(G(s.IPV6.replaceAll(":", ""))) : void 0;
      return i.Relay.new_single_host_addr(i.SingleHostAddr.new(s.port, e, t));
    }
    case "SingleHostName":
      return i.Relay.new_single_host_name(i.SingleHostName.new(s.port, i.DNSRecordAorAAAA.new(s.domainName)));
    case "MultiHostName":
      return i.Relay.new_multi_host_name(i.MultiHostName.new(i.DNSRecordSRV.new(s.domainName)));
  }
}, Mr = (s) => {
  if (s.is_plutus_script()) {
    const t = s.plutus_script();
    return {
      code: t.to_hex(),
      version: Object.keys(St).find((r) => St[r].to_hex() === t.language_version().to_hex())
    };
  }
  const e = s.native_script();
  return ye(e);
}, Xt = (s) => {
  if ("code" in s) {
    const e = jt(s.code, s.version);
    return i.ScriptRef.new_plutus_script(e);
  }
  return i.ScriptRef.new_native_script(xe(s));
}, Ie = (s) => {
  var n, a, c;
  const e = s.output().has_data_hash() ? (n = s.output().data_hash()) == null ? void 0 : n.to_hex() : void 0, t = s.output().has_plutus_data() ? (a = s.output().plutus_data()) == null ? void 0 : a.to_hex() : void 0, r = s.output().has_script_ref() ? (c = s.output().script_ref()) == null ? void 0 : c.to_hex() : void 0;
  return {
    input: {
      outputIndex: s.input().index(),
      txHash: s.input().transaction_id().to_hex()
    },
    output: {
      address: s.output().address().to_bech32(),
      amount: Kr(s.output().amount()),
      dataHash: e,
      plutusData: t,
      scriptRef: r
    }
  };
}, xt = (s) => {
  const e = i.TransactionInput.new(Nr(s.input.txHash), s.input.outputIndex), t = i.TransactionOutput.new(It(s.output.address), bt(s.output.amount));
  return s.output.dataHash !== void 0 && t.set_data_hash(Os(s.output.dataHash)), s.output.plutusData !== void 0 && t.set_plutus_data(Tr(s.output.plutusData)), s.output.scriptRef !== void 0 && t.set_script_ref(Hs(s.output.scriptRef)), i.TransactionUnspentOutput.new(e, t);
}, fr = (s) => {
  const e = s.split(".")[1] ?? "0", t = `${parseInt(e, 10)}`, r = "1" + "0".repeat(e.length);
  return i.UnitInterval.new(i.BigNum.from_str(t), i.BigNum.from_str(r));
}, ot = (s) => s.length % 2 === 0 && /^[0-9A-F]*$/i.test(s) ? s : lt(Buffer.from(s, "utf-8")), Ge = (s) => Buffer.from(s, "hex").toString("utf-8"), Kr = (s) => {
  const e = [
    { unit: "lovelace", quantity: s.coin().to_str() }
  ], t = s.multiasset();
  if (t !== void 0) {
    const r = t.keys();
    for (let n = 0; n < r.len(); n += 1) {
      const a = r.get(n), c = t.get(a);
      if (c !== void 0) {
        const l = c.keys();
        for (let p = 0; p < l.len(); p += 1) {
          const A = l.get(p), C = c.get(A) ?? i.BigNum.from_str("0"), E = a.to_hex() + lt(A.name());
          e.push({ unit: E, quantity: C.to_str() });
        }
      }
    }
  }
  return e;
}, bt = (s) => {
  const e = s.find((a) => a.unit === "lovelace"), t = Array.from(new Set(s.filter((a) => a.unit !== "lovelace").map((a) => a.unit.slice(0, Ct)))), r = i.MultiAsset.new();
  t.forEach((a) => {
    const c = i.Assets.new();
    s.filter((l) => l.unit.slice(0, Ct) === a).forEach((l) => {
      c.insert(i.AssetName.new(G(l.unit.slice(Ct))), i.BigNum.from_str(l.quantity));
    }), r.insert(Fs(a), c);
  });
  const n = i.Value.new(i.BigNum.from_str(e ? e.quantity : "0"));
  return (s.length > 1 || !e) && n.set_multiasset(r), n;
}, gr = (s, e, t) => i.BaseAddress.new(s, i.StakeCredential.from_keyhash(e), i.StakeCredential.from_keyhash(t)), Hr = (s, e = "") => i.Bip32PrivateKey.from_bip39_entropy(G(s), G(ot(e))), Ue = (s) => i.DataCost.new_coins_per_byte(i.BigNum.from_str(s)), Vs = (s) => {
  if (typeof s != "object" || !("input" in s))
    return i.DatumSource.new(Ot(s));
  const e = xt(s);
  if (e.output().has_plutus_data())
    return i.DatumSource.new_ref_input(e.input());
  throw new Error(`No inline datum found in UTxO: ${e.input().transaction_id().to_hex()}`);
}, mr = (s, e) => i.EnterpriseAddress.new(s, i.StakeCredential.from_keyhash(e)), Ar = (s, e) => {
  if (typeof s == "string")
    return i.MintWitness.new_native_script(_e(s));
  if (e === void 0)
    throw new Error("Minting with plutus requires a redeemer to be defined");
  if (e.tag !== "MINT")
    throw new Error("Minting redeemer's tag must be defined as 'MINT'");
  return i.MintWitness.new_plutus_script(Me(s), Pe({
    tag: "MINT",
    index: 0,
    budget: Gt,
    data: {
      alternative: 0,
      fields: []
    },
    ...e
  }));
}, Oe = (s, e) => i.RewardAddress.new(s, i.StakeCredential.from_keyhash(e)), Me = (s) => {
  if ("code" in s)
    return i.PlutusScriptSource.new(jt(s.code, s.version));
  const e = xt(s);
  if (e.output().has_script_ref()) {
    const t = e.output().script_ref();
    if (t.is_plutus_script()) {
      const r = Mr(t), n = jt(r.code, r.version).hash();
      return i.PlutusScriptSource.new_ref_input_with_lang_ver(n, e.input(), St[r.version]);
    }
  }
  throw new Error(`No plutus script reference found in UTxO: ${e.input().transaction_id().to_hex()}`);
}, ue = (s) => {
  const e = i.ScriptPubkey.new(s);
  return i.NativeScript.new_script_pubkey(e);
}, me = (s = ft) => {
  const e = i.TransactionBuilderConfigBuilder.new().coins_per_utxo_byte(i.BigNum.from_str(s.coinsPerUTxOSize)).ex_unit_prices(i.ExUnitPrices.new(fr(s.priceMem.toString()), fr(s.priceStep.toString()))).fee_algo(i.LinearFee.new(i.BigNum.from_str(s.minFeeA.toString()), i.BigNum.from_str(s.minFeeB.toString()))).key_deposit(i.BigNum.from_str(s.keyDeposit)).max_tx_size(s.maxTxSize).max_value_size(parseInt(s.maxValSize, 10)).pool_deposit(i.BigNum.from_str(s.poolDeposit)).build();
  return i.TransactionBuilder.new(e);
}, pr = (s) => {
  const e = i.TxInputsBuilder.new();
  return s.map((t) => t instanceof i.TransactionUnspentOutput ? t : xt(t)).forEach((t) => {
    e.add_input(t.output().address(), t.input(), t.output().amount());
  }), e;
}, le = (s) => {
  if (typeof s == "string")
    return i.TransactionOutputBuilder.new().with_address(It(s));
  let e = i.TransactionOutputBuilder.new().with_address(It(s.address));
  if (s.datum) {
    const { value: t, inline: r } = s.datum, n = Ot(t);
    e = e.with_data_hash(i.hash_plutus_data(n)), r && (e = e.with_plutus_data(n));
  }
  if (s.script) {
    const t = Xt(s.script);
    e = e.with_script_ref(t);
  }
  return e;
}, Kt = (s) => {
  const e = s.slice(0, Ct), t = s.includes(".") ? ot(s.split(".")[1]) : s.slice(Ct);
  return { policyId: e, assetName: t };
}, S = (s) => Mt.isAxiosError(s) ? s.response ? JSON.stringify({
  data: s.response.data,
  headers: s.response.headers,
  status: s.response.status
}) : s.request ? JSON.stringify(s.request) : s.message : JSON.stringify(s), on = (s) => {
  const e = Ot(s);
  return i.hash_plutus_data(e).to_hex();
}, cn = (s, e = Date.now()) => {
  if (Ae[s]) {
    const [t, r, n, a] = Ae[s];
    return parseInt(i.BigNum.from_str(e.toString()).div_floor(i.BigNum.from_str("1000")).checked_sub(i.BigNum.from_str(n)).div_floor(i.BigNum.from_str(a)).checked_add(i.BigNum.from_str(t)).to_str(), 10);
  }
  throw new Error(`Couldn't resolve EpochNo for network: ${s}`);
}, Ls = (s, e) => Ns.fromParts(G(s), G(e)).fingerprint(), un = (s, e) => Zr[s][e], ln = (s) => xe(s).hash().to_hex(), Yt = (s) => {
  var e, t;
  try {
    const r = [
      (e = Le(s)) == null ? void 0 : e.payment_cred().to_keyhash(),
      (t = Pr(s)) == null ? void 0 : t.payment_cred().to_keyhash()
    ].find((n) => n !== void 0);
    if (r !== void 0)
      return r.to_hex();
    throw new Error(`Couldn't resolve payment key hash from address: ${s}`);
  } catch (r) {
    throw new Error(`An error occurred during resolvePaymentKeyHash: ${r}.`);
  }
}, hn = (s, e = 0) => {
  const t = jt(s.code, s.version);
  return i.EnterpriseAddress.new(e, i.StakeCredential.from_scripthash(t.hash())).to_address().to_bech32();
}, dn = (s) => {
  try {
    const e = Pr(s), t = e == null ? void 0 : e.payment_cred().to_scripthash();
    if (t !== void 0)
      return t.to_hex();
    throw new Error(`Couldn't resolve script hash from address: ${s}`);
  } catch (e) {
    throw new Error(`An error occurred during resolveScriptHash: ${e}.`);
  }
}, fn = (s) => i.Ed25519KeyHash.from_hex(s).to_bech32("pool1"), gn = (s) => {
  const e = _r(s.join(" ")), t = Hr(e), r = t.to_bech32();
  return t.free(), r;
}, mn = (s) => Xt(s).to_hex(), An = (s, e = Date.now()) => {
  if (Ae[s]) {
    const [t, r, n] = Ae[s];
    return i.BigNum.from_str(e.toString()).div_floor(i.BigNum.from_str("1000")).checked_sub(i.BigNum.from_str(n)).checked_add(i.BigNum.from_str(r)).to_str();
  }
  throw new Error(`Couldn't resolve SlotNo for network: ${s}`);
}, we = (s) => {
  try {
    const e = It(s), t = Le(s), r = t == null ? void 0 : t.stake_cred().to_keyhash();
    if (r !== void 0)
      return Oe(e.network_id(), r).to_address().to_bech32();
    throw new Error(`Couldn't resolve reward address from address: ${s}`);
  } catch (e) {
    throw new Error(`An error occurred during resolveRewardAddress: ${e}.`);
  }
}, re = (s) => {
  var e, t;
  try {
    const r = [
      (e = Le(s)) == null ? void 0 : e.stake_cred().to_keyhash(),
      (t = Ur(s)) == null ? void 0 : t.payment_cred().to_keyhash()
    ].find((n) => n !== void 0);
    if (r !== void 0)
      return r.to_hex();
    throw new Error(`Couldn't resolve stake key hash from address: ${s}`);
  } catch (r) {
    throw new Error(`An error occurred during resolveStakeKeyHash: ${r}.`);
  }
}, Fr = (s, e = ft.minFeeA, t = ft.minFeeB) => (BigInt(e) * BigInt(s) + BigInt(t)).toString(), Gs = (s) => {
  const e = pt(s).body();
  return i.hash_transaction(e).to_hex();
}, pn = (s = "", e = 32) => {
  if (e <= 0 || e > 2048)
    throw new Error("Length must be bewteen 1 and 2048");
  const r = Ir("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")(e);
  return ot(`${s}${r}`);
}, Ke = (s, e) => {
  const t = s.vkeys();
  if (t !== void 0) {
    const r = /* @__PURE__ */ new Set();
    for (let a = 0; a < t.len(); a += 1)
      r.add(t.get(a).to_hex());
    for (let a = 0; a < e.len(); a += 1)
      r.add(e.get(a).to_hex());
    const n = i.Vkeywitnesses.new();
    return r.forEach((a) => {
      n.add(i.Vkeywitness.from_hex(a));
    }), n;
  }
  return e;
}, In = (s) => ge(Tr(s)), _n = (s) => pt(s).to_js_value();
class yn {
  _axiosInstance;
  constructor(...e) {
    if (typeof e[0] == "string" && e[0].startsWith("http"))
      this._axiosInstance = Mt.create({ baseURL: e[0] });
    else {
      const t = e[0], r = t.slice(0, 7);
      this._axiosInstance = Mt.create({
        baseURL: `https://cardano-${r}.blockfrost.io/api/v${e[1] ?? 0}`,
        headers: { project_id: t }
      });
    }
  }
  async fetchAccountInfo(e) {
    const t = e.startsWith("addr") ? we(e) : e;
    try {
      const { data: r, status: n } = await this._axiosInstance.get(`accounts/${t}`);
      if (n === 200)
        return {
          poolId: r.pool_id,
          active: r.active || r.active_epoch !== null,
          balance: r.controlled_amount,
          rewards: r.withdrawable_amount,
          withdrawals: r.withdrawals_sum
        };
      throw S(r);
    } catch (r) {
      throw S(r);
    }
  }
  resolveScriptRef = async (e) => {
    if (e) {
      const { data: t, status: r } = await this._axiosInstance.get(`scripts/${e}`);
      if (r === 200) {
        const n = t.type.startsWith("plutus") ? {
          code: await this.fetchPlutusScriptCBOR(e),
          version: t.type.replace("plutus", "")
        } : await this.fetchNativeScriptJSON(e);
        return Xt(n).to_hex();
      }
      throw S(t);
    }
  };
  toUTxO = async (e, t) => ({
    input: {
      outputIndex: e.output_index,
      txHash: t
    },
    output: {
      address: e.address,
      amount: e.amount,
      dataHash: e.data_hash ?? void 0,
      plutusData: e.inline_datum ?? void 0,
      scriptRef: await this.resolveScriptRef(e.reference_script_hash),
      scriptHash: e.reference_script_hash
    }
  });
  async fetchAddressUTxOs(e, t) {
    const r = t !== void 0 ? `/${t}` : "", n = `addresses/${e}/utxos` + r, a = async (c = 1, l = []) => {
      const { data: p, status: A } = await this._axiosInstance.get(`${n}?page=${c}`);
      if (A === 200)
        return p.length > 0 ? a(c + 1, [
          ...l,
          ...await Promise.all(p.map((C) => this.toUTxO(C, C.tx_hash)))
        ]) : l;
      throw S(p);
    };
    try {
      return await a();
    } catch {
      return [];
    }
  }
  async fetchAssetAddresses(e) {
    const t = async (r = 1, n = []) => {
      const { policyId: a, assetName: c } = Kt(e), { data: l, status: p } = await this._axiosInstance.get(`assets/${a}${c}/addresses?page=${r}`);
      if (p === 200)
        return l.length > 0 ? t(r + 1, [...n, ...l]) : n;
      throw S(l);
    };
    try {
      return await t();
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(e) {
    try {
      const { policyId: t, assetName: r } = Kt(e), { data: n, status: a } = await this._axiosInstance.get(`assets/${t}${r}`);
      if (a === 200)
        return {
          ...n.onchain_metadata
        };
      throw S(n);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchBlockInfo(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`blocks/${e}`);
      if (r === 200)
        return {
          confirmations: t.confirmations,
          epoch: t.epoch,
          epochSlot: t.epoch_slot.toString(),
          fees: t.fees,
          hash: t.hash,
          nextBlock: t.next_block ?? "",
          operationalCertificate: t.op_cert,
          output: t.output ?? "0",
          previousBlock: t.previous_block,
          size: t.size,
          slot: t.slot.toString(),
          slotLeader: t.slot_leader ?? "",
          time: t.time,
          txCount: t.tx_count,
          VRFKey: t.block_vrf
        };
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchCollectionAssets(e, t = 1) {
    try {
      const { data: r, status: n } = await this._axiosInstance.get(`assets/policy/${e}?page=${t}`);
      if (n === 200)
        return {
          assets: r.map((a) => ({
            unit: a.asset,
            quantity: a.quantity
          })),
          next: r.length === 100 ? t + 1 : null
        };
      throw S(r);
    } catch {
      return { assets: [], next: null };
    }
  }
  async fetchHandleAddress(e) {
    try {
      const t = ot(e.replace("$", "")), { data: r, status: n } = await this._axiosInstance.get(`assets/${Fe[1]}${t}/addresses`);
      if (n === 200)
        return r[0].address;
      throw S(r);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchProtocolParameters(e = Number.NaN) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`epochs/${isNaN(e) ? "latest" : e}/parameters`);
      if (r === 200)
        return {
          coinsPerUTxOSize: t.coins_per_utxo_word,
          collateralPercent: t.collateral_percent,
          decentralisation: t.decentralisation_param,
          epoch: t.epoch,
          keyDeposit: t.key_deposit,
          maxBlockExMem: t.max_block_ex_mem,
          maxBlockExSteps: t.max_block_ex_steps,
          maxBlockHeaderSize: t.max_block_header_size,
          maxBlockSize: t.max_block_size,
          maxCollateralInputs: t.max_collateral_inputs,
          maxTxExMem: t.max_tx_ex_mem,
          maxTxExSteps: t.max_tx_ex_steps,
          maxTxSize: t.max_tx_size,
          maxValSize: t.max_val_size,
          minFeeA: t.min_fee_a,
          minFeeB: t.min_fee_b,
          minPoolCost: t.min_pool_cost,
          poolDeposit: t.pool_deposit,
          priceMem: t.price_mem,
          priceStep: t.price_step
        };
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchTxInfo(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`txs/${e}`);
      if (r === 200)
        return {
          block: t.block,
          deposit: t.deposit,
          fees: t.fees,
          hash: t.hash,
          index: t.index,
          invalidAfter: t.invalid_hereafter ?? "",
          invalidBefore: t.invalid_before ?? "",
          slot: t.slot.toString(),
          size: t.size
        };
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchUTxOs(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`txs/${e}/utxos`);
      if (r === 200) {
        const n = t.outputs, a = [];
        return n.forEach((l) => {
          a.push(this.toUTxO(l, e));
        }), await Promise.all(a);
      }
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  onTxConfirmed(e, t, r = 100) {
    let n = 0;
    const a = setInterval(() => {
      n >= r && clearInterval(a), this.fetchTxInfo(e).then((c) => {
        this.fetchBlockInfo(c.block).then((l) => {
          (l == null ? void 0 : l.confirmations) > 0 && (clearInterval(a), t());
        }).catch(() => {
          n += 1;
        });
      }).catch(() => {
        n += 1;
      });
    }, 5e3);
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/cbor" }, { data: r, status: n } = await this._axiosInstance.post("tx/submit", G(e), { headers: t });
      if (n === 200)
        return r;
      throw S(r);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchPlutusScriptCBOR(e) {
    const { data: t, status: r } = await this._axiosInstance.get(`scripts/${e}/cbor`);
    if (r === 200)
      return t.cbor;
    throw S(t);
  }
  async fetchNativeScriptJSON(e) {
    const { data: t, status: r } = await this._axiosInstance.get(`scripts/${e}/json`);
    if (r === 200)
      return t.json;
    throw S(t);
  }
}
class xn {
  _axiosInstance;
  constructor(e, t, r) {
    const n = r.host ?? "ipfs.infura.io", a = r.port ?? 5001, c = r.version ?? 0;
    this._axiosInstance = Mt.create({
      baseURL: `https://${n}:${a}/api/v${c}`,
      auth: { username: e, password: t }
    });
  }
  async uploadContent(e, t = !1) {
    try {
      const r = { "Content-Type": "multipart/form-data" }, { data: n, status: a } = await this._axiosInstance.post(`add?recursive=${t}`, e, { headers: r });
      if (a === 200)
        return n;
      throw S(n);
    } catch (r) {
      throw S(r);
    }
  }
}
class wn {
  _axiosInstance;
  constructor(...e) {
    typeof e[0] == "string" && e[0].startsWith("http") ? this._axiosInstance = Mt.create({
      baseURL: e[0],
      headers: {
        Authorization: `Bearer ${e[1]}`
      }
    }) : this._axiosInstance = Mt.create({
      baseURL: `https://${e[0]}.koios.rest/api/v${e[2] ?? 0}`,
      headers: {
        Authorization: `Bearer ${e[1]}`
      }
    });
  }
  async fetchAccountInfo(e) {
    try {
      const t = e.startsWith("addr") ? we(e) : e, { data: r, status: n } = await this._axiosInstance.post("account_info", {
        _stake_addresses: [t]
      });
      if (n === 200)
        return {
          poolId: r[0].delegated_pool,
          active: r[0].status === "registered",
          balance: r[0].total_balance.toString(),
          rewards: r[0].rewards_available,
          withdrawals: r[0].withdrawals
        };
      throw S(r);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchAddressUTxOs(e, t) {
    try {
      const { data: r, status: n } = await this._axiosInstance.post("address_info", {
        _addresses: [e]
      });
      if (n === 200) {
        const a = r.flatMap((c) => c.utxo_set).map((c) => this.toUTxO(c, e));
        return t !== void 0 ? a.filter((c) => c.output.amount.find((l) => l.unit === t) !== void 0) : a;
      }
      throw S(r);
    } catch {
      return [];
    }
  }
  async fetchAssetAddresses(e) {
    try {
      const { policyId: t, assetName: r } = Kt(e), { data: n, status: a } = await this._axiosInstance.get(`asset_address_list?_asset_policy=${t}&_asset_name=${r}`);
      if (a === 200)
        return n.map((c) => ({
          address: c.payment_address,
          quantity: c.quantity
        }));
      throw S(n);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchAssetMetadata(e) {
    try {
      const { policyId: t, assetName: r } = Kt(e), { data: n, status: a } = await this._axiosInstance.get(`asset_info?_asset_policy=${t}&_asset_name=${r}`);
      if (a === 200)
        return {
          ...n[0].minting_tx_metadata[721][t][Ge(r)]
        };
      throw S(n);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchBlockInfo(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.post("block_info", {
        _block_hashes: [e]
      });
      if (r === 200)
        return {
          confirmations: t[0].num_confirmations,
          epoch: t[0].epoch_no,
          epochSlot: t[0].epoch_slot.toString(),
          fees: t[0].total_fees ?? "",
          hash: t[0].hash,
          nextBlock: t[0].child_hash ?? "",
          operationalCertificate: t[0].op_cert,
          output: t[0].total_output ?? "0",
          previousBlock: t[0].parent_hash,
          size: t[0].block_size,
          slot: t[0].abs_slot.toString(),
          slotLeader: t[0].pool ?? "",
          time: t[0].block_time,
          txCount: t[0].tx_count,
          VRFKey: t[0].vrf_key
        };
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchCollectionAssets(e, t = 0) {
    try {
      const { data: r, status: n } = await this._axiosInstance.get(`asset_policy_info?_asset_policy=${e}&limit=100&offset=${t}`);
      if (n === 200)
        return {
          assets: r.map((a) => ({
            unit: `${e}${a.asset_name}`,
            quantity: a.total_supply
          })),
          next: r.length === 100 ? t + 100 : null
        };
      throw S(r);
    } catch (r) {
      throw S(r);
    }
  }
  async fetchHandleAddress(e) {
    try {
      const t = ot(e.replace("$", "")), { data: r, status: n } = await this._axiosInstance.get(`asset_address_list?_asset_policy=${Fe[1]}&_asset_name=${t}`);
      if (n === 200)
        return r[0].payment_address;
      throw S(r);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchProtocolParameters(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`epoch_params?_epoch_no=${e}`);
      if (r === 200)
        return {
          coinsPerUTxOSize: t[0].coins_per_utxo_size,
          collateralPercent: t[0].collateral_percent,
          decentralisation: t[0].decentralisation,
          epoch: t[0].epoch_no,
          keyDeposit: t[0].key_deposit,
          maxBlockExMem: t[0].max_block_ex_mem.toString(),
          maxBlockExSteps: t[0].max_block_ex_steps.toString(),
          maxBlockHeaderSize: t[0].max_bh_size,
          maxBlockSize: t[0].max_block_size,
          maxCollateralInputs: t[0].max_collateral_inputs,
          maxTxExMem: t[0].max_tx_ex_mem.toString(),
          maxTxExSteps: t[0].max_tx_ex_steps.toString(),
          maxTxSize: t[0].max_tx_size,
          maxValSize: t[0].max_val_size.toString(),
          minFeeA: t[0].min_fee_a,
          minFeeB: t[0].min_fee_b,
          minPoolCost: t[0].min_pool_cost,
          poolDeposit: t[0].pool_deposit,
          priceMem: t[0].price_mem,
          priceStep: t[0].price_step
        };
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchTxInfo(e) {
    var t, r;
    try {
      const { data: n, status: a } = await this._axiosInstance.post("tx_info", {
        _tx_hashes: [e]
      });
      if (a === 200)
        return {
          block: n[0].block_hash,
          deposit: n[0].deposit,
          fees: n[0].fee,
          hash: n[0].tx_hash,
          index: n[0].tx_block_index,
          invalidAfter: ((t = n[0].invalid_after) == null ? void 0 : t.toString()) ?? "",
          invalidBefore: ((r = n[0].invalid_before) == null ? void 0 : r.toString()) ?? "",
          slot: n[0].absolute_slot.toString(),
          size: n[0].tx_size
        };
      throw S(n);
    } catch (n) {
      throw S(n);
    }
  }
  async fetchUTxOs(e) {
    try {
      console.log("hi");
      const { data: t, status: r } = await this._axiosInstance.post("tx_info", {
        _tx_hashes: [e]
      });
      if (r === 200)
        return console.log(t[0]), t[0].outputs.map((a) => this.toUTxO(a, a.payment_addr.bech32));
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  onTxConfirmed(e, t, r = 100) {
    let n = 0;
    const a = setInterval(() => {
      n >= r && clearInterval(a), this.fetchTxInfo(e).then((c) => {
        this.fetchBlockInfo(c.block).then((l) => {
          (l == null ? void 0 : l.confirmations) > 0 && (clearInterval(a), t());
        }).catch(() => {
          n += 1;
        });
      }).catch(() => {
        n += 1;
      });
    }, 5e3);
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/cbor" }, { data: r, status: n } = await this._axiosInstance.post("submittx", G(e), { headers: t });
      if (n === 202)
        return r;
      throw S(r);
    } catch (t) {
      throw S(t);
    }
  }
  toUTxO(e, t) {
    var r, n;
    return {
      input: {
        outputIndex: e.tx_index,
        txHash: e.tx_hash
      },
      output: {
        address: t,
        amount: [
          { unit: "lovelace", quantity: e.value },
          ...e.asset_list.map((a) => ({
            unit: `${a.policy_id}${a.asset_name}`,
            quantity: `${a.quantity}`
          }))
        ],
        dataHash: e.datum_hash ?? void 0,
        plutusData: ((r = e.inline_datum) == null ? void 0 : r.bytes) ?? void 0,
        scriptRef: this.resolveScriptRef(e.reference_script),
        scriptHash: ((n = e.reference_script) == null ? void 0 : n.hash) ?? void 0
      }
    };
  }
  resolveScriptRef = (e) => {
    if (e) {
      const t = e.type.startsWith("plutus") ? {
        code: e.bytes,
        version: e.type.replace("plutus", "")
      } : ye(_e(e.bytes));
      return Xt(t).to_hex();
    }
  };
}
class Cn {
  _baseUrl;
  constructor(...e) {
    this._baseUrl = jr(e[0]) ? ts[e[0]] : e[0];
  }
  async evaluateTx(e) {
    const t = await this.open();
    return this.send(t, "EvaluateTx", {
      evaluate: e
    }), new Promise((r, n) => {
      t.addEventListener("message", (a) => {
        try {
          const { result: c } = JSON.parse(a.data);
          c.EvaluationResult ? r(Object.keys(c.EvaluationResult).map((l) => ({
            index: parseInt(l.split(":")[1], 10),
            tag: l.split(":")[0].toUpperCase(),
            budget: {
              mem: c.EvaluationResult[l].memory,
              steps: c.EvaluationResult[l].steps
            }
          }))) : n(c.EvaluationFailure), t.close();
        } catch (c) {
          n(c);
        }
      }, { once: !0 });
    });
  }
  async onNextTx(e) {
    const t = await this.open();
    return this.send(t, "AwaitAcquire", {}), t.addEventListener("message", (r) => {
      const { result: n } = JSON.parse(r.data);
      if (n === null)
        return this.send(t, "AwaitAcquire", {});
      n.AwaitAcquired === void 0 && e(n), this.send(t, "NextTx", {});
    }), () => t.close();
  }
  async submitTx(e) {
    const t = await this.open();
    return this.send(t, "SubmitTx", {
      submit: e
    }), new Promise((r, n) => {
      t.addEventListener("message", (a) => {
        try {
          const { result: c } = JSON.parse(a.data);
          c.SubmitSuccess ? r(c.SubmitSuccess.txId) : n(c.SubmitFail), t.close();
        } catch (c) {
          n(c);
        }
      }, { once: !0 });
    });
  }
  async open() {
    const e = new WebSocket(this._baseUrl);
    return await new Promise((t) => {
      e.addEventListener("open", () => t(!0), { once: !0 });
    }), e;
  }
  send(e, t, r) {
    e.send(JSON.stringify({
      version: "1.0",
      type: "jsonwsp/request",
      servicename: "ogmios",
      methodname: t,
      args: r
    }));
  }
}
class Bn {
  _axiosInstance;
  constructor(e, t, r, n = 1) {
    this._axiosInstance = Mt.create({
      baseURL: `https://cardano-${e}.tangocrypto.com/${t}/v${n}`,
      headers: { "x-api-key": r }
    });
  }
  async evaluateTx(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.post("transactions/evaluate", { tx: e, utxos: [] });
      if (r === 200)
        return t.redeemers.map((n) => ({
          index: n.index,
          tag: n.purpose.toUpperCase(),
          budget: {
            mem: n.unit_mem,
            steps: n.unit_steps
          }
        }));
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchAccountInfo(e) {
    try {
      const t = e.startsWith("addr") ? we(e) : e, { data: r, status: n } = await this._axiosInstance.get(`wallets/${t}`);
      if (n === 200)
        return {
          poolId: r.pool_id,
          active: r.active,
          balance: r.controlled_total_stake,
          rewards: r.rewards_sum,
          withdrawals: r.withdrawals_sum
        };
      throw S(r);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchAddressUTxOs(e, t) {
    const r = t !== void 0 ? `/assets/${t}` : "", n = `addresses/${e}${r}/utxos?size=50`, a = async (A = "", C = []) => {
      var b;
      const { data: E, status: w } = await this._axiosInstance.get(`${n}&cursor=${A}`);
      if (w === 200)
        return E.cursor !== null && ((b = E.cursor) == null ? void 0 : b.length) > 0 ? a(E.cursor, [...C, ...E.data.map(p)]) : E.data.map(p);
      throw S(E);
    }, c = (A, C) => {
      const E = [
        {
          unit: "lovelace",
          quantity: A.toString()
        }
      ];
      return C.forEach((w) => {
        const b = ot(w.asset_name);
        E.push({
          unit: `${w.policy_id}${b}`,
          quantity: w.quantity.toString()
        });
      }), E;
    }, l = (A) => {
      if (A) {
        const C = A.type.startsWith("plutus") ? {
          code: A.code,
          version: A.type.replace("plutus", "")
        } : ye(_e(A.json));
        return Xt(C).to_hex();
      }
    }, p = (A) => {
      var C;
      return {
        input: {
          outputIndex: A.index,
          txHash: A.hash
        },
        output: {
          address: e,
          amount: c(A.value, A.assets),
          dataHash: void 0,
          plutusData: ((C = A.inline_datum) == null ? void 0 : C.value_raw) ?? void 0,
          scriptRef: l(A.reference_script)
        }
      };
    };
    try {
      return await a();
    } catch {
      return [];
    }
  }
  async fetchAssetAddresses(e) {
    const t = (n) => ({
      address: n.address,
      quantity: n.quantity.toString()
    }), r = async (n = "", a = []) => {
      var C;
      const { policyId: c, assetName: l } = Kt(e), { data: p, status: A } = await this._axiosInstance.get(`assets/${c}${l}/addresses?size=100&cursor=${n}`);
      if (A === 200)
        return p.cursor !== null && ((C = p.cursor) == null ? void 0 : C.length) > 0 ? r(p.cursor, [
          ...a,
          ...p.data.map(t)
        ]) : p.data.map(t);
      throw S(p);
    };
    try {
      return await r();
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(e) {
    var t;
    try {
      const { policyId: r, assetName: n } = Kt(e), { data: a, status: c } = await this._axiosInstance.get(`assets/${r}${n}`);
      if (c === 200)
        return {
          ...(t = a.metadata.find((l) => l.label === 721)) == null ? void 0 : t.json[r][Ge(n)]
        };
      throw S(a);
    } catch (r) {
      throw S(r);
    }
  }
  async fetchBlockInfo(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`blocks/${e}`);
      if (r === 200)
        return {
          confirmations: t.confirmations,
          epoch: t.epoch_no,
          epochSlot: t.epoch_slot_no.toString(),
          fees: t.fees.toString(),
          hash: t.hash,
          nextBlock: t.next_block.toString() ?? "",
          operationalCertificate: t.op_cert,
          output: t.out_sum.toString() ?? "0",
          previousBlock: t.previous_block.toString(),
          size: t.size,
          slot: t.slot_no.toString(),
          slotLeader: t.slot_leader ?? "",
          time: Date.parse(t.time),
          txCount: t.tx_count,
          VRFKey: t.vrf_key
        };
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchCollectionAssets(e, t = "") {
    try {
      const { data: r, status: n } = await this._axiosInstance.get(`policies/${e}/assets?size=100&cursor=${t}`);
      if (n === 200)
        return {
          assets: r.data.map((a) => ({
            unit: `${a.policy_id}${a.asset_name}`,
            quantity: a.quantity
          })),
          next: r.cursor
        };
      throw S(r);
    } catch {
      return { assets: [], next: null };
    }
  }
  async fetchHandleAddress(e) {
    try {
      const t = ot(e.replace("$", "")), { data: r, status: n } = await this._axiosInstance.get(`assets/${Fe[1]}${t}/addresses`);
      if (n === 200)
        return r.data[0].address;
      throw S(r);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchProtocolParameters(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`epochs/${e}/parameters`);
      if (r === 200)
        return {
          coinsPerUTxOSize: t.coins_per_utxo_size.toString(),
          collateralPercent: t.collateral_percent,
          decentralisation: t.decentralisation,
          epoch: t.epoch_no,
          keyDeposit: t.key_deposit.toString(),
          maxBlockExMem: t.max_block_ex_mem.toString(),
          maxBlockExSteps: t.max_block_ex_steps.toString(),
          maxBlockHeaderSize: t.max_block_header_size,
          maxBlockSize: t.max_block_size,
          maxCollateralInputs: t.max_collateral_inputs,
          maxTxExMem: t.max_tx_ex_mem.toString(),
          maxTxExSteps: t.max_tx_ex_steps.toString(),
          maxTxSize: t.max_tx_size,
          maxValSize: t.max_val_size.toString(),
          minFeeA: t.min_fee_a,
          minFeeB: t.min_fee_b,
          minPoolCost: t.min_pool_cost.toString(),
          poolDeposit: t.pool_deposit.toString(),
          priceMem: t.price_mem,
          priceStep: t.price_step
        };
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchTxInfo(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`transactions/${e}`);
      if (r === 200)
        return {
          block: t.block.hash,
          deposit: t.deposit,
          fees: t.fee,
          hash: t.hash,
          index: t.block_index,
          invalidAfter: t.invalid_hereafter ?? "",
          invalidBefore: t.invalid_before ?? "",
          slot: t.block.slot_no.toString(),
          size: t.size
        };
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchUTxOs(e) {
    try {
      return console.log(e), [];
    } catch (t) {
      throw S(t);
    }
  }
  onTxConfirmed(e, t, r = 100) {
    let n = 0;
    const a = setInterval(() => {
      n >= r && clearInterval(a), this.fetchTxInfo(e).then((c) => {
        this.fetchBlockInfo(c.block).then((l) => {
          (l == null ? void 0 : l.confirmations) > 0 && (clearInterval(a), t());
        }).catch(() => {
          n += 1;
        });
      }).catch(() => {
        n += 1;
      });
    }, 5e3);
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/json" }, { data: r, status: n } = await this._axiosInstance.post("transactions/submit", { tx: e }, { headers: t });
      if (n === 200)
        return r.tx_id;
      throw S(r);
    } catch (t) {
      throw S(t);
    }
  }
}
class En {
  _axiosInstance;
  _amountsAsStrings = {
    headers: {
      "amounts-as-strings": "true"
    }
  };
  submitUrl;
  constructor({ network: e, apiKey: t, turboSubmit: r = !1 }) {
    this._axiosInstance = Mt.create({
      baseURL: `https://${e}.gomaestro-api.org/v1`,
      headers: { "api-key": t }
    }), this.submitUrl = r ? "txmanager/turbosubmit" : "txmanager";
  }
  async evaluateTx(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.post("transactions/evaluate", { cbor: e });
      if (r === 200) {
        const n = {
          spend: "SPEND",
          mint: "MINT",
          cert: "CERT",
          wdrl: "REWARD"
        };
        return t.map((c) => {
          const l = c.ex_units, p = c.redeemer_index, A = n[c.redeemer_tag];
          return { budget: l, index: p, tag: A };
        });
      }
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchAccountInfo(e) {
    const t = e.startsWith("addr") ? we(e) : e;
    try {
      const { data: r, status: n } = await this._axiosInstance.get(`accounts/${t}`, this._amountsAsStrings);
      if (n === 200) {
        const a = r.data;
        return {
          poolId: a.delegated_pool,
          active: a.registered,
          balance: a.total_balance,
          rewards: a.rewards_available,
          withdrawals: a.total_withdrawn
        };
      }
      throw S(r);
    } catch (r) {
      throw S(r);
    }
  }
  async fetchAddressUTxOs(e, t) {
    const r = (() => e.startsWith("addr_vkh") || e.startsWith("addr_shared_vkh") ? `addresses/cred/${e}` : `addresses/${e}`)(), n = t ? `&asset=${t}` : "", a = async (c = null, l = []) => {
      const p = c === null ? "" : `&cursor=${c}`, { data: A, status: C } = await this._axiosInstance.get(`${r}/utxos?count=100${n}${p}`, this._amountsAsStrings);
      if (C === 200) {
        const w = A.data.map(this.toUTxO), b = [...l, ...w], P = A.next_cursor;
        return P == null ? b : a(P, b);
      }
      throw S(A);
    };
    try {
      return await a();
    } catch {
      return [];
    }
  }
  async fetchAssetAddresses(e) {
    const { policyId: t, assetName: r } = Kt(e), n = async (a = null, c = []) => {
      const l = a === null ? "" : `&cursor=${a}`, { data: p, status: A } = await this._axiosInstance.get(`assets/${t}${r}/addresses?count=100${l}`, this._amountsAsStrings);
      if (A === 200) {
        const E = p.data.map((P) => ({ address: P.address, quantity: P.amount })), w = p.next_cursor, b = [
          ...c,
          ...E
        ];
        return w == null ? b : n(w, b);
      }
      throw S(p);
    };
    try {
      return await n();
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(e) {
    try {
      const { policyId: t, assetName: r } = Kt(e), { data: n, status: a } = await this._axiosInstance.get(`assets/${t}${r}`);
      if (a === 200) {
        const c = n.data;
        return {
          ...c.asset_standards.cip25_metadata,
          ...c.asset_standards.cip68_metadata
        };
      }
      throw S(n);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchBlockInfo(e) {
    var t;
    try {
      const { data: r, status: n } = await this._axiosInstance.get(`blocks/${e}`, this._amountsAsStrings);
      if (n === 200) {
        const a = r.data;
        return {
          confirmations: a.confirmations,
          epoch: a.epoch,
          epochSlot: a.epoch_slot.toString(),
          fees: a.total_fees,
          hash: a.hash,
          nextBlock: a.next_block ?? "",
          operationalCertificate: (t = a.operational_certificate) == null ? void 0 : t.hot_vkey,
          output: a.total_output_lovelace ?? "0",
          previousBlock: a.previous_block,
          size: a.size,
          slot: a.absolute_slot.toString(),
          slotLeader: a.block_producer ?? "",
          time: Date.parse(a.timestamp) / 1e3,
          txCount: a.tx_hashes.length,
          VRFKey: i.VRFVKey.from_hex(a.vrf_key).to_bech32("vrf_vk")
        };
      }
      throw S(r);
    } catch (r) {
      throw S(r);
    }
  }
  async fetchCollectionAssets(e, t) {
    try {
      const { data: r, status: n } = await this._axiosInstance.get(`policy/${e}/assets?count=100${t ? `&cursor=${t}` : ""}`);
      if (n === 200)
        return {
          assets: r.data.map((c) => ({
            unit: e + c.asset_name,
            quantity: c.total_supply
          })),
          next: r.next_cursor
        };
      throw S(r);
    } catch {
      return { assets: [], next: null };
    }
  }
  async fetchHandleAddress(e) {
    try {
      const t = e.charAt(0) === "$" ? e.substring(1) : e, { data: r, status: n } = await this._axiosInstance.get(`ecosystem/adahandle/${t}`);
      if (n === 200)
        return r.data;
      throw S(r);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchProtocolParameters(e = Number.NaN) {
    if (!isNaN(e))
      throw new Error("Maestro only supports fetching Protocol parameters of the latest completed epoch.");
    const t = (r) => {
      const n = r.indexOf("/");
      return parseInt(r.slice(0, n)) / parseInt(r.slice(n + 1));
    };
    try {
      const { data: r, status: n } = await this._axiosInstance.get("protocol-params");
      if (n === 200) {
        const a = r.data;
        try {
          const { data: c, status: l } = await this._axiosInstance.get("epochs/current");
          if (l === 200) {
            const p = c.data;
            return {
              coinsPerUTxOSize: a.coins_per_utxo_byte.toString(),
              collateralPercent: parseInt(a.collateral_percentage),
              decentralisation: 0,
              epoch: parseInt(p.epoch_no),
              keyDeposit: a.stake_key_deposit.toString(),
              maxBlockExMem: a.max_execution_units_per_block.memory.toString(),
              maxBlockExSteps: a.max_execution_units_per_block.steps.toString(),
              maxBlockHeaderSize: parseInt(a.max_block_header_size),
              maxBlockSize: parseInt(a.max_block_body_size),
              maxCollateralInputs: parseInt(a.max_collateral_inputs),
              maxTxExMem: a.max_execution_units_per_transaction.memory.toString(),
              maxTxExSteps: a.max_execution_units_per_transaction.steps.toString(),
              maxTxSize: parseInt(a.max_tx_size),
              maxValSize: a.max_value_size.toString(),
              minFeeA: a.min_fee_coefficient,
              minFeeB: a.min_fee_constant,
              minPoolCost: a.min_pool_cost.toString(),
              poolDeposit: a.pool_deposit.toString(),
              priceMem: t(a.prices.memory),
              priceStep: t(a.prices.steps)
            };
          }
          throw S(c);
        } catch (c) {
          throw S(c);
        }
      }
      throw S(r);
    } catch (r) {
      throw S(r);
    }
  }
  async fetchTxInfo(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`transactions/${e}`);
      if (r === 200) {
        const n = t.data;
        return {
          block: n.block_hash,
          deposit: n.deposit.toString(),
          fees: n.fee.toString(),
          hash: n.tx_hash,
          index: n.block_tx_index,
          invalidAfter: n.invalid_hereafter ?? "",
          invalidBefore: n.invalid_before ?? "",
          slot: n.block_absolute_slot.toString(),
          size: n.size - 1
        };
      }
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  async fetchUTxOs(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`transactions/${e}`, this._amountsAsStrings);
      if (r === 200)
        return t.data.outputs.map(this.toUTxO);
      throw S(t);
    } catch (t) {
      throw S(t);
    }
  }
  onTxConfirmed(e, t, r = 100) {
    let n = 0;
    const a = setInterval(() => {
      n >= r && clearInterval(a), this.fetchTxInfo(e).then((c) => {
        this.fetchBlockInfo(c.block).then((l) => {
          (l == null ? void 0 : l.confirmations) > 0 && (clearInterval(a), t());
        }).catch(() => {
          n += 1;
        });
      }).catch(() => {
        n += 1;
      });
    }, 5e3);
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/cbor" }, { data: r, status: n } = await this._axiosInstance.post(this.submitUrl, G(e), { headers: t });
      if (n === 202)
        return r;
      throw S(r);
    } catch (t) {
      throw S(t);
    }
  }
  toUTxO = (e) => {
    var t, r, n;
    return {
      input: {
        outputIndex: e.index,
        txHash: e.tx_hash
      },
      output: {
        address: e.address,
        amount: e.assets.map((a) => ({
          unit: a.unit,
          quantity: a.amount
        })),
        dataHash: (t = e.datum) == null ? void 0 : t.hash,
        plutusData: (r = e.datum) == null ? void 0 : r.bytes,
        scriptRef: this.resolveScript(e),
        scriptHash: (n = e.reference_script) == null ? void 0 : n.hash
      }
    };
  };
  resolveScript = (e) => {
    if (e.reference_script) {
      const t = e.reference_script.type === "native" ? e.reference_script.json : {
        code: e.reference_script.bytes,
        version: e.reference_script.type.replace("plutusv", "V")
      };
      return Xt(t).to_hex();
    } else
      return;
  };
}
class Sn {
  static withOneSignature(e) {
    const t = wt(Yt(e));
    return ue(t).to_hex();
  }
  static withAtLeastNSignatures(e, t) {
    const r = i.NativeScripts.new();
    e.forEach((a) => {
      const c = wt(Yt(a));
      r.add(ue(c));
    });
    const n = i.ScriptNOfK.new(t, r);
    return i.NativeScript.new_script_any(n).to_hex();
  }
  static withAnySignature(e) {
    const t = i.NativeScripts.new();
    e.forEach((n) => {
      const a = wt(Yt(n));
      t.add(ue(a));
    });
    const r = i.ScriptAny.new(t);
    return i.NativeScript.new_script_any(r).to_hex();
  }
  static withAllSignatures(e) {
    const t = i.NativeScripts.new();
    e.forEach((n) => {
      const a = wt(Yt(n));
      t.add(ue(a));
    });
    const r = i.ScriptAll.new(t);
    return i.NativeScript.new_script_any(r).to_hex();
  }
  static fromNativeScript(e) {
    return xe(e).to_hex();
  }
}
function Ht(s, e, t, r) {
  var n = arguments.length, a = n < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, c;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    a = Reflect.decorate(s, e, t, r);
  else
    for (var l = s.length - 1; l >= 0; l--)
      (c = s[l]) && (a = (n < 3 ? c(a) : n > 3 ? c(e, t, a) : c(e, t)) || a);
  return n > 3 && a && Object.defineProperty(e, t, a), a;
}
const Ys = (s) => class extends s {
  __visits = [];
}, Vt = () => function(s, e, t) {
  const r = t.value;
  t.value = function(...n) {
    const a = r.call(this, ...n);
    return this.__visits && this.__visits.push(e), a;
  };
};
let Dt = class {
  _changeAddress;
  _txOutputs = /* @__PURE__ */ new Map();
  _recipients = /* @__PURE__ */ new Map();
  _totalBurns = /* @__PURE__ */ new Map();
  _totalMints = /* @__PURE__ */ new Map();
  _era;
  _initiator;
  _mintBuilder;
  _protocolParameters;
  _txBuilder;
  _txCertificates;
  _txInputsBuilder;
  _txWithdrawals;
  constructor(e = {}) {
    this._era = e.era, this._initiator = e.initiator, this._mintBuilder = i.MintBuilder.new(), this._protocolParameters = e.parameters ?? ft, this._txBuilder = me(e.parameters), this._txCertificates = i.Certificates.new(), this._txInputsBuilder = i.TxInputsBuilder.new(), this._txWithdrawals = i.Withdrawals.new();
  }
  static attachMetadata(e, t, r = "BABBAGE") {
    var c;
    const n = pt(e), a = n.auxiliary_data() ?? i.AuxiliaryData.new();
    if (a.set_metadata(i.GeneralTransactionMetadata.from_hex(t)), a.set_prefer_alonzo_format(r === "ALONZO"), i.hash_auxiliary_data(a).to_hex() !== ((c = n.body().auxiliary_data_hash()) == null ? void 0 : c.to_hex()))
      throw new Error("[Transaction] attachMetadata: The metadata hash does not match the auxiliary data hash.");
    return i.Transaction.new(n.body(), n.witness_set(), a).to_hex();
  }
  static deattachMetadata(e) {
    const t = pt(e);
    return i.Transaction.new(t.body(), t.witness_set(), void 0).to_hex();
  }
  static maskMetadata(e, t = "BABBAGE") {
    var a;
    const r = pt(e), n = (a = r.auxiliary_data()) == null ? void 0 : a.metadata();
    if (n !== void 0) {
      const c = i.GeneralTransactionMetadata.new();
      for (let p = 0; p < n.len(); p += 1) {
        const A = n.keys().get(p), C = n.get(A);
        c.insert(A, i.TransactionMetadatum.from_hex("0".repeat(((C == null ? void 0 : C.to_hex()) ?? "").length)));
      }
      const l = r.auxiliary_data();
      return l !== void 0 && (l.set_metadata(c), l.set_prefer_alonzo_format(t === "ALONZO")), i.Transaction.new(r.body(), r.witness_set(), l).to_hex();
    }
    return e;
  }
  static readMetadata(e) {
    var r, n;
    return ((n = (r = pt(e).auxiliary_data()) == null ? void 0 : r.metadata()) == null ? void 0 : n.to_hex()) ?? "";
  }
  static writeMetadata(e, t, r = "BABBAGE") {
    const n = pt(e), a = n.auxiliary_data() ?? i.AuxiliaryData.new();
    return a.set_metadata(i.GeneralTransactionMetadata.from_hex(t)), a.set_prefer_alonzo_format(r === "ALONZO"), i.Transaction.new(n.body(), n.witness_set(), a).to_hex();
  }
  get size() {
    return this._txBuilder.full_size();
  }
  async build() {
    try {
      return (this._mintBuilder.has_plutus_scripts() || this.notVisited("redeemValue") === !1) && (await this.addRequiredSignersIfNeeded(), await this.addCollateralIfNeeded()), await this.forgeAssetsIfNeeded(), await this.addTxInputsAsNeeded(), await this.addChangeAddress(), this._txBuilder.build_tx().to_hex();
    } catch (e) {
      throw new Error(`[Transaction] An error occurred during build: ${e}.`);
    }
  }
  burnAsset(e, t, r) {
    const n = this._totalBurns.has(t.unit) ? i.BigNum.from_str(this._totalBurns.get(t.unit) ?? "0").checked_add(i.BigNum.from_str(t.quantity)).to_str() : t.quantity;
    return this._mintBuilder.add_asset(Ar(e, r), i.AssetName.new(G(t.unit.slice(Ct))), i.Int.new_negative(i.BigNum.from_str(t.quantity))), this._totalBurns.set(t.unit, n), this;
  }
  delegateStake(e, t) {
    const r = i.Certificate.new_stake_delegation(i.StakeDelegation.new(i.StakeCredential.from_keyhash(wt(re(e))), i.Ed25519KeyHash.from_bech32(t)));
    return this._txCertificates.add(r), this;
  }
  deregisterStake(e) {
    const t = i.Certificate.new_stake_deregistration(i.StakeDeregistration.new(i.StakeCredential.from_keyhash(wt(re(e)))));
    return this._txCertificates.add(t), this;
  }
  mintAsset(e, t, r) {
    var A, C;
    const n = (E, w) => {
      const b = typeof E == "string" ? _e(E).hash().to_hex() : a(E).hash().to_hex(), P = ot(w.assetName);
      return {
        unit: `${b}${P}`,
        quantity: w.assetQuantity
      };
    }, a = (E) => {
      if ("code" in E)
        return jt(E.code, E.version);
      const w = xt(E);
      if (w.output().has_script_ref()) {
        const b = w.output().script_ref();
        if (b.is_plutus_script()) {
          const P = Mr(b);
          return jt(P.code, P.version);
        }
      }
      throw new Error(`[Transaction] No plutus script reference found in UTxO: ${w.input().transaction_id().to_hex()}`);
    }, c = n(e, t), p = i.BigNum.from_str(((A = this._totalMints.get(c.unit)) == null ? void 0 : A.assetQuantity) ?? "0").checked_add(i.BigNum.from_str(c.quantity));
    return this._mintBuilder.add_asset(Ar(e, r), i.AssetName.new(G(ot(t.assetName))), i.Int.new(i.BigNum.from_str(c.quantity))), this._recipients.has(t.recipient) ? (C = this._recipients.get(t.recipient)) == null || C.push(c) : this._recipients.set(t.recipient, [c]), this._totalMints.set(c.unit, {
      ...t,
      assetQuantity: p.to_str()
    }), this;
  }
  redeemValue(e) {
    const t = {
      tag: "SPEND",
      budget: Gt,
      index: this._txInputsBuilder.inputs().len(),
      data: {
        alternative: 0,
        fields: []
      },
      ...e.redeemer
    }, r = xt(e.value), n = e.datum ? i.PlutusWitness.new_with_ref(Me(e.script), Vs(e.datum), Pe(t)) : i.PlutusWitness.new_with_ref_without_datum(Me(e.script), Pe(t));
    return this._txInputsBuilder.add_plutus_script_input(n, r.input(), r.output().amount()), this;
  }
  registerStake(e) {
    const t = i.Certificate.new_stake_registration(i.StakeRegistration.new(i.StakeCredential.from_keyhash(wt(re(e)))));
    return this._txCertificates.add(t), this;
  }
  registerPool(e) {
    const t = i.Certificate.new_pool_registration(i.PoolRegistration.new(qs(e)));
    return this._txCertificates.add(t), this;
  }
  retirePool(e, t) {
    const r = i.Certificate.new_pool_retirement(i.PoolRetirement.new(i.Ed25519KeyHash.from_bech32(e), t));
    return this._txCertificates.add(r), this;
  }
  sendAssets(e, t) {
    const r = bt(t), n = r.multiasset();
    if (r.is_zero() || n === void 0)
      return this;
    const a = le(e).next(), c = r.coin().is_zero() ? a.with_asset_and_min_required_coin_by_utxo_cost(n, Ue(this._protocolParameters.coinsPerUTxOSize)).build() : a.with_coin_and_asset(r.coin(), n).build();
    return t.forEach((l) => {
      this.setTxOutput(l);
    }), this._txBuilder.add_output(c), this;
  }
  sendLovelace(e, t) {
    const n = le(e).next().with_coin(i.BigNum.from_str(t)).build();
    return this.setTxOutput({
      unit: "lovelace",
      quantity: t
    }), this._txBuilder.add_output(n), this;
  }
  sendToken(e, t, r) {
    return this.sendAssets(e, [{
      quantity: r,
      unit: es[t]
    }]), this;
  }
  sendValue(e, t) {
    const r = bt(t.output.amount), a = le(e).next().with_value(r).build();
    return t.output.amount.forEach((c) => {
      this.setTxOutput(c);
    }), this._txBuilder.add_output(a), this;
  }
  setChangeAddress(e) {
    return this._changeAddress = It(e), this;
  }
  setCollateral(e) {
    const t = pr(e);
    return this._txBuilder.set_collateral(t), this;
  }
  setMetadata(e, t) {
    return this._txBuilder.add_json_metadatum_with_schema(i.BigNum.from_str(e.toString()), JSON.stringify(t), i.MetadataJsonSchema.NoConversions), this;
  }
  setRequiredSigners(e) {
    return Array.from(new Set(e.map((r) => r.startsWith("addr") ? Yt(r) : re(r)).map((r) => wt(r)))).forEach((r) => {
      this._txBuilder.add_required_signer(r);
    }), this;
  }
  setTimeToStart(e) {
    return this._txBuilder.set_validity_start_interval_bignum(i.BigNum.from_str(e)), this;
  }
  setTimeToExpire(e) {
    return this._txBuilder.set_ttl_bignum(i.BigNum.from_str(e)), this;
  }
  setTxInputs(e) {
    return e.map((t) => xt(t)).forEach((t) => {
      this._txInputsBuilder.add_input(t.output().address(), t.input(), t.output().amount());
    }), this;
  }
  setTxRefInputs(e) {
    return e.map((t) => xt(t)).forEach((t) => {
      this._txBuilder.add_reference_input(t.input());
    }), this;
  }
  withdrawRewards(e, t) {
    const r = Ur(e);
    return r !== void 0 && this._txWithdrawals.insert(r, i.BigNum.from_str(t)), this;
  }
  async addBurnInputsIfNeeded() {
    if (this._initiator && this._totalBurns.size > 0 && this.notVisited("setTxInputs")) {
      const e = await this._initiator.getUsedUTxOs();
      ss(this._totalBurns, e.map((r) => Ie(r))).map((r) => xt(r)).forEach((r) => {
        this._txInputsBuilder.add_input(r.output().address(), r.input(), r.output().amount());
      });
    }
  }
  async addChangeAddress() {
    if (this._initiator && this._changeAddress === void 0) {
      const e = await this._initiator.getUsedAddress();
      this._txBuilder.add_change_if_needed(e);
    } else
      this._changeAddress !== void 0 && this._txBuilder.add_change_if_needed(this._changeAddress);
  }
  async addCollateralIfNeeded() {
    if (this._initiator && this.notVisited("setCollateral")) {
      const e = await this._initiator.getUsedCollateral();
      this._txBuilder.set_collateral(pr(e));
    }
  }
  async addRequiredSignersIfNeeded() {
    if (this._initiator && this.notVisited("setRequiredSigners")) {
      const e = await this._initiator.getUsedAddress(), t = Yt(e.to_bech32());
      this._txBuilder.add_required_signer(wt(t));
    }
  }
  async addTxInputsAsNeeded() {
    if (this.notVisited("setTxInputs")) {
      const e = await this.filterAvailableUTxOs();
      rs(this._txOutputs, e.map((r) => Ie(r))).map((r) => xt(r)).forEach((r) => {
        this._txInputsBuilder.add_input(r.output().address(), r.input(), r.output().amount());
      });
    }
    if (this._txBuilder.set_inputs(this._txInputsBuilder), (this._mintBuilder.has_native_scripts() || this._mintBuilder.has_plutus_scripts()) && this._txBuilder.set_mint_builder(this._mintBuilder), this._txCertificates.len() > 0 && this._txBuilder.set_certs(this._txCertificates), this._txWithdrawals.len() > 0 && this._txBuilder.set_withdrawals(this._txWithdrawals), this._txBuilder.get_mint_builder() || this.notVisited("redeemValue") === !1) {
      const e = this._era !== void 0 ? Je[this._era] : Je.BABBAGE;
      this._txBuilder.calc_script_data_hash(e);
    }
  }
  async forgeAssetsIfNeeded() {
    const e = (t, r) => {
      const n = t.data.assetName, a = t.data.metadata, c = t.unit.slice(0, Ct);
      if (t.data.label === "777")
        return a;
      if (r && r[c]) {
        const { [c]: l, ...p } = r, A = {
          [n]: a,
          ...l
        };
        return {
          [c]: {
            ...A
          },
          ...p
        };
      }
      return r !== void 0 ? {
        [c]: {
          [n]: a
        },
        ...r
      } : {
        [c]: { [n]: a }
      };
    };
    await this.addBurnInputsIfNeeded(), Array.from(this._totalMints, (t) => ({
      unit: t[0],
      data: t[1]
    })).reduce((t, r) => t.set(r.data.label, e(r, t.get(r.data.label))), /* @__PURE__ */ new Map()).forEach((t, r) => {
      this._txBuilder.add_json_metadatum(i.BigNum.from_str(r), JSON.stringify(t));
    }), this.addMintOutputs();
  }
  async filterAvailableUTxOs(e = []) {
    return this._initiator === void 0 ? [] : (await this._initiator.getUsedUTxOs()).filter((r) => e.find((n) => n.input.txHash === r.input().transaction_id().to_hex()) === void 0);
  }
  addMintOutputs() {
    this._recipients.forEach((e, t) => {
      const n = bt(e).multiasset();
      if (n !== void 0) {
        const c = le(t).next().with_asset_and_min_required_coin_by_utxo_cost(n, Ue(this._protocolParameters.coinsPerUTxOSize)).build();
        this._txBuilder.add_output(c);
      }
    });
  }
  notVisited(e) {
    return this.__visits.includes(e) === !1;
  }
  setTxOutput(e) {
    const r = i.BigNum.from_str(this._txOutputs.get(e.unit) ?? "0").checked_add(i.BigNum.from_str(e.quantity)).to_str();
    this._txOutputs.set(e.unit, r);
  }
};
Ht([
  Vt()
], Dt.prototype, "mintAsset", null);
Ht([
  Vt()
], Dt.prototype, "redeemValue", null);
Ht([
  Vt()
], Dt.prototype, "sendAssets", null);
Ht([
  Vt()
], Dt.prototype, "sendValue", null);
Ht([
  Vt()
], Dt.prototype, "setCollateral", null);
Ht([
  Vt()
], Dt.prototype, "setRequiredSigners", null);
Ht([
  Vt()
], Dt.prototype, "setTxInputs", null);
Dt = Ht([
  Ys
], Dt);
const $s = (s, e, t) => {
  const r = new Map(e);
  r.set("lovelace", String(Number(r.get("lovelace")) + Number(t)));
  const n = /* @__PURE__ */ new Map();
  for (let w = 0; w < s.length; w++)
    n.set(w, s[w]);
  const a = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set(), p = /* @__PURE__ */ new Set(), A = /* @__PURE__ */ new Set();
  for (let w = 0; w < s.length; w++)
    switch (s[w].output.amount.length) {
      case 1: {
        c.add(w);
        break;
      }
      case 2: {
        l.add(w);
        break;
      }
      case 3: {
        p.add(w);
        break;
      }
      default: {
        A.add(w);
        break;
      }
    }
  const C = (w, b, P) => {
    const k = n.get(w);
    if (!k)
      return;
    const N = zs(k, b);
    if (Number(N) > 0) {
      a.add(w), P.delete(w);
      for (const T of k.output.amount)
        r.set(T.unit, String(Number(r.get(T.unit)) - Number(T.quantity)));
    }
  };
  for (const w of r.keys())
    if (w != "lovelace") {
      for (const b of l) {
        const P = r.get(w);
        if (!P || Number(P) <= 0)
          break;
        C(b, w, l);
      }
      for (const b of p) {
        const P = r.get(w);
        if (!P || Number(P) <= 0)
          break;
        C(b, w, p);
      }
      for (const b of A) {
        const P = r.get(w);
        if (!P || Number(P) <= 0)
          break;
        C(b, w, A);
      }
    }
  for (const w of c) {
    const b = r.get("lovelace");
    if (!b || Number(b) <= 0)
      break;
    C(w, "lovelace", c);
  }
  for (const w of l) {
    const b = r.get("lovelace");
    if (!b || Number(b) <= 0)
      break;
    C(w, "lovelace", l);
  }
  for (const w of p) {
    const b = r.get("lovelace");
    if (!b || Number(b) <= 0)
      break;
    C(w, "lovelace", p);
  }
  for (const w of A) {
    const b = r.get("lovelace");
    if (!b || Number(b) <= 0)
      break;
    C(w, "lovelace", A);
  }
  for (const w of r.keys())
    if (Number(r.get(w)) > 0)
      return [];
  const E = [];
  for (const w of a) {
    const b = n.get(w);
    b && E.push(b);
  }
  return E;
}, zs = (s, e) => {
  for (const t of s.output.amount)
    if (t.unit == e)
      return t.quantity;
  return "0";
};
var zt = { exports: {} }, Rr = { exports: {} }, Ye = { exports: {} };
(function(s) {
  (function(e) {
    var t, r = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, n = Math.ceil, a = Math.floor, c = "[BigNumber Error] ", l = c + "Number primitive has more than 15 significant digits: ", p = 1e14, A = 14, C = 9007199254740991, E = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], w = 1e7, b = 1e9;
    function P(O) {
      var M, z, X, D = v.prototype = { constructor: v, toString: null, valueOf: null }, F = new v(1), q = 20, W = 4, st = -7, ut = 21, Ft = -1e7, mt = 1e7, Rt = !1, Zt = 1, kt = 0, Ce = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "\xA0",
        suffix: ""
      }, qt = "0123456789abcdefghijklmnopqrstuvwxyz", Be = !0;
      function v(o, u) {
        var h, _, f, m, x, d, g, y, I = this;
        if (!(I instanceof v))
          return new v(o, u);
        if (u == null) {
          if (o && o._isBigNumber === !0) {
            I.s = o.s, !o.c || o.e > mt ? I.c = I.e = null : o.e < Ft ? I.c = [I.e = 0] : (I.e = o.e, I.c = o.c.slice());
            return;
          }
          if ((d = typeof o == "number") && o * 0 == 0) {
            if (I.s = 1 / o < 0 ? (o = -o, -1) : 1, o === ~~o) {
              for (m = 0, x = o; x >= 10; x /= 10, m++)
                ;
              m > mt ? I.c = I.e = null : (I.e = m, I.c = [o]);
              return;
            }
            y = String(o);
          } else {
            if (!r.test(y = String(o)))
              return X(I, y, d);
            I.s = y.charCodeAt(0) == 45 ? (y = y.slice(1), -1) : 1;
          }
          (m = y.indexOf(".")) > -1 && (y = y.replace(".", "")), (x = y.search(/e/i)) > 0 ? (m < 0 && (m = x), m += +y.slice(x + 1), y = y.substring(0, x)) : m < 0 && (m = y.length);
        } else {
          if (Q(u, 2, qt.length, "Base"), u == 10 && Be)
            return I = new v(o), ht(I, q + I.e + 1, W);
          if (y = String(o), d = typeof o == "number") {
            if (o * 0 != 0)
              return X(I, y, d, u);
            if (I.s = 1 / o < 0 ? (y = y.slice(1), -1) : 1, v.DEBUG && y.replace(/^0\.0*|\./, "").length > 15)
              throw Error(l + o);
          } else
            I.s = y.charCodeAt(0) === 45 ? (y = y.slice(1), -1) : 1;
          for (h = qt.slice(0, u), m = x = 0, g = y.length; x < g; x++)
            if (h.indexOf(_ = y.charAt(x)) < 0) {
              if (_ == ".") {
                if (x > m) {
                  m = g;
                  continue;
                }
              } else if (!f && (y == y.toUpperCase() && (y = y.toLowerCase()) || y == y.toLowerCase() && (y = y.toUpperCase()))) {
                f = !0, x = -1, m = 0;
                continue;
              }
              return X(I, String(o), d, u);
            }
          d = !1, y = z(y, u, 10, I.s), (m = y.indexOf(".")) > -1 ? y = y.replace(".", "") : m = y.length;
        }
        for (x = 0; y.charCodeAt(x) === 48; x++)
          ;
        for (g = y.length; y.charCodeAt(--g) === 48; )
          ;
        if (y = y.slice(x, ++g)) {
          if (g -= x, d && v.DEBUG && g > 15 && (o > C || o !== a(o)))
            throw Error(l + I.s * o);
          if ((m = m - x - 1) > mt)
            I.c = I.e = null;
          else if (m < Ft)
            I.c = [I.e = 0];
          else {
            if (I.e = m, I.c = [], x = (m + 1) % A, m < 0 && (x += A), x < g) {
              for (x && I.c.push(+y.slice(0, x)), g -= A; x < g; )
                I.c.push(+y.slice(x, x += A));
              x = A - (y = y.slice(x)).length;
            } else
              x -= g;
            for (; x--; y += "0")
              ;
            I.c.push(+y);
          }
        } else
          I.c = [I.e = 0];
      }
      v.clone = P, v.ROUND_UP = 0, v.ROUND_DOWN = 1, v.ROUND_CEIL = 2, v.ROUND_FLOOR = 3, v.ROUND_HALF_UP = 4, v.ROUND_HALF_DOWN = 5, v.ROUND_HALF_EVEN = 6, v.ROUND_HALF_CEIL = 7, v.ROUND_HALF_FLOOR = 8, v.EUCLID = 9, v.config = v.set = function(o) {
        var u, h;
        if (o != null)
          if (typeof o == "object") {
            if (o.hasOwnProperty(u = "DECIMAL_PLACES") && (h = o[u], Q(h, 0, b, u), q = h), o.hasOwnProperty(u = "ROUNDING_MODE") && (h = o[u], Q(h, 0, 8, u), W = h), o.hasOwnProperty(u = "EXPONENTIAL_AT") && (h = o[u], h && h.pop ? (Q(h[0], -b, 0, u), Q(h[1], 0, b, u), st = h[0], ut = h[1]) : (Q(h, -b, b, u), st = -(ut = h < 0 ? -h : h))), o.hasOwnProperty(u = "RANGE"))
              if (h = o[u], h && h.pop)
                Q(h[0], -b, -1, u), Q(h[1], 1, b, u), Ft = h[0], mt = h[1];
              else if (Q(h, -b, b, u), h)
                Ft = -(mt = h < 0 ? -h : h);
              else
                throw Error(c + u + " cannot be zero: " + h);
            if (o.hasOwnProperty(u = "CRYPTO"))
              if (h = o[u], h === !!h)
                if (h)
                  if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                    Rt = h;
                  else
                    throw Rt = !h, Error(c + "crypto unavailable");
                else
                  Rt = h;
              else
                throw Error(c + u + " not true or false: " + h);
            if (o.hasOwnProperty(u = "MODULO_MODE") && (h = o[u], Q(h, 0, 9, u), Zt = h), o.hasOwnProperty(u = "POW_PRECISION") && (h = o[u], Q(h, 0, b, u), kt = h), o.hasOwnProperty(u = "FORMAT"))
              if (h = o[u], typeof h == "object")
                Ce = h;
              else
                throw Error(c + u + " not an object: " + h);
            if (o.hasOwnProperty(u = "ALPHABET"))
              if (h = o[u], typeof h == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(h))
                Be = h.slice(0, 10) == "0123456789", qt = h;
              else
                throw Error(c + u + " invalid: " + h);
          } else
            throw Error(c + "Object expected: " + o);
        return {
          DECIMAL_PLACES: q,
          ROUNDING_MODE: W,
          EXPONENTIAL_AT: [st, ut],
          RANGE: [Ft, mt],
          CRYPTO: Rt,
          MODULO_MODE: Zt,
          POW_PRECISION: kt,
          FORMAT: Ce,
          ALPHABET: qt
        };
      }, v.isBigNumber = function(o) {
        if (!o || o._isBigNumber !== !0)
          return !1;
        if (!v.DEBUG)
          return !0;
        var u, h, _ = o.c, f = o.e, m = o.s;
        t:
          if ({}.toString.call(_) == "[object Array]") {
            if ((m === 1 || m === -1) && f >= -b && f <= b && f === a(f)) {
              if (_[0] === 0) {
                if (f === 0 && _.length === 1)
                  return !0;
                break t;
              }
              if (u = (f + 1) % A, u < 1 && (u += A), String(_[0]).length == u) {
                for (u = 0; u < _.length; u++)
                  if (h = _[u], h < 0 || h >= p || h !== a(h))
                    break t;
                if (h !== 0)
                  return !0;
              }
            }
          } else if (_ === null && f === null && (m === null || m === 1 || m === -1))
            return !0;
        throw Error(c + "Invalid BigNumber: " + o);
      }, v.maximum = v.max = function() {
        return $e(arguments, -1);
      }, v.minimum = v.min = function() {
        return $e(arguments, 1);
      }, v.random = function() {
        var o = 9007199254740992, u = Math.random() * o & 2097151 ? function() {
          return a(Math.random() * o);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(h) {
          var _, f, m, x, d, g = 0, y = [], I = new v(F);
          if (h == null ? h = q : Q(h, 0, b), x = n(h / A), Rt)
            if (crypto.getRandomValues) {
              for (_ = crypto.getRandomValues(new Uint32Array(x *= 2)); g < x; )
                d = _[g] * 131072 + (_[g + 1] >>> 11), d >= 9e15 ? (f = crypto.getRandomValues(new Uint32Array(2)), _[g] = f[0], _[g + 1] = f[1]) : (y.push(d % 1e14), g += 2);
              g = x / 2;
            } else if (crypto.randomBytes) {
              for (_ = crypto.randomBytes(x *= 7); g < x; )
                d = (_[g] & 31) * 281474976710656 + _[g + 1] * 1099511627776 + _[g + 2] * 4294967296 + _[g + 3] * 16777216 + (_[g + 4] << 16) + (_[g + 5] << 8) + _[g + 6], d >= 9e15 ? crypto.randomBytes(7).copy(_, g) : (y.push(d % 1e14), g += 7);
              g = x / 7;
            } else
              throw Rt = !1, Error(c + "crypto unavailable");
          if (!Rt)
            for (; g < x; )
              d = u(), d < 9e15 && (y[g++] = d % 1e14);
          for (x = y[--g], h %= A, x && h && (d = E[A - h], y[g] = a(x / d) * d); y[g] === 0; y.pop(), g--)
            ;
          if (g < 0)
            y = [m = 0];
          else {
            for (m = -1; y[0] === 0; y.splice(0, 1), m -= A)
              ;
            for (g = 1, d = y[0]; d >= 10; d /= 10, g++)
              ;
            g < A && (m -= A - g);
          }
          return I.e = m, I.c = y, I;
        };
      }(), v.sum = function() {
        for (var o = 1, u = arguments, h = new v(u[0]); o < u.length; )
          h = h.plus(u[o++]);
        return h;
      }, z = function() {
        var o = "0123456789";
        function u(h, _, f, m) {
          for (var x, d = [0], g, y = 0, I = h.length; y < I; ) {
            for (g = d.length; g--; d[g] *= _)
              ;
            for (d[0] += m.indexOf(h.charAt(y++)), x = 0; x < d.length; x++)
              d[x] > f - 1 && (d[x + 1] == null && (d[x + 1] = 0), d[x + 1] += d[x] / f | 0, d[x] %= f);
          }
          return d.reverse();
        }
        return function(h, _, f, m, x) {
          var d, g, y, I, B, U, K, L, Z = h.indexOf("."), et = q, V = W;
          for (Z >= 0 && (I = kt, kt = 0, h = h.replace(".", ""), L = new v(_), U = L.pow(h.length - Z), kt = I, L.c = u(
            Y(N(U.c), U.e, "0"),
            10,
            f,
            o
          ), L.e = L.c.length), K = u(h, _, f, x ? (d = qt, o) : (d = o, qt)), y = I = K.length; K[--I] == 0; K.pop())
            ;
          if (!K[0])
            return d.charAt(0);
          if (Z < 0 ? --y : (U.c = K, U.e = y, U.s = m, U = M(U, L, et, V, f), K = U.c, B = U.r, y = U.e), g = y + et + 1, Z = K[g], I = f / 2, B = B || g < 0 || K[g + 1] != null, B = V < 4 ? (Z != null || B) && (V == 0 || V == (U.s < 0 ? 3 : 2)) : Z > I || Z == I && (V == 4 || B || V == 6 && K[g - 1] & 1 || V == (U.s < 0 ? 8 : 7)), g < 1 || !K[0])
            h = B ? Y(d.charAt(1), -et, d.charAt(0)) : d.charAt(0);
          else {
            if (K.length = g, B)
              for (--f; ++K[--g] > f; )
                K[g] = 0, g || (++y, K = [1].concat(K));
            for (I = K.length; !K[--I]; )
              ;
            for (Z = 0, h = ""; Z <= I; h += d.charAt(K[Z++]))
              ;
            h = Y(h, y, d.charAt(0));
          }
          return h;
        };
      }(), M = function() {
        function o(_, f, m) {
          var x, d, g, y, I = 0, B = _.length, U = f % w, K = f / w | 0;
          for (_ = _.slice(); B--; )
            g = _[B] % w, y = _[B] / w | 0, x = K * g + y * U, d = U * g + x % w * w + I, I = (d / m | 0) + (x / w | 0) + K * y, _[B] = d % m;
          return I && (_ = [I].concat(_)), _;
        }
        function u(_, f, m, x) {
          var d, g;
          if (m != x)
            g = m > x ? 1 : -1;
          else
            for (d = g = 0; d < m; d++)
              if (_[d] != f[d]) {
                g = _[d] > f[d] ? 1 : -1;
                break;
              }
          return g;
        }
        function h(_, f, m, x) {
          for (var d = 0; m--; )
            _[m] -= d, d = _[m] < f[m] ? 1 : 0, _[m] = d * x + _[m] - f[m];
          for (; !_[0] && _.length > 1; _.splice(0, 1))
            ;
        }
        return function(_, f, m, x, d) {
          var g, y, I, B, U, K, L, Z, et, V, $, nt, ae, ve, be, _t, te, dt = _.s == f.s ? 1 : -1, at = _.c, tt = f.c;
          if (!at || !at[0] || !tt || !tt[0])
            return new v(
              !_.s || !f.s || (at ? tt && at[0] == tt[0] : !tt) ? NaN : at && at[0] == 0 || !tt ? dt * 0 : dt / 0
            );
          for (Z = new v(dt), et = Z.c = [], y = _.e - f.e, dt = m + y + 1, d || (d = p, y = k(_.e / A) - k(f.e / A), dt = dt / A | 0), I = 0; tt[I] == (at[I] || 0); I++)
            ;
          if (tt[I] > (at[I] || 0) && y--, dt < 0)
            et.push(1), B = !0;
          else {
            for (ve = at.length, _t = tt.length, I = 0, dt += 2, U = a(d / (tt[0] + 1)), U > 1 && (tt = o(tt, U, d), at = o(at, U, d), _t = tt.length, ve = at.length), ae = _t, V = at.slice(0, _t), $ = V.length; $ < _t; V[$++] = 0)
              ;
            te = tt.slice(), te = [0].concat(te), be = tt[0], tt[1] >= d / 2 && be++;
            do {
              if (U = 0, g = u(tt, V, _t, $), g < 0) {
                if (nt = V[0], _t != $ && (nt = nt * d + (V[1] || 0)), U = a(nt / be), U > 1)
                  for (U >= d && (U = d - 1), K = o(tt, U, d), L = K.length, $ = V.length; u(K, V, L, $) == 1; )
                    U--, h(K, _t < L ? te : tt, L, d), L = K.length, g = 1;
                else
                  U == 0 && (g = U = 1), K = tt.slice(), L = K.length;
                if (L < $ && (K = [0].concat(K)), h(V, K, $, d), $ = V.length, g == -1)
                  for (; u(tt, V, _t, $) < 1; )
                    U++, h(V, _t < $ ? te : tt, $, d), $ = V.length;
              } else
                g === 0 && (U++, V = [0]);
              et[I++] = U, V[0] ? V[$++] = at[ae] || 0 : (V = [at[ae]], $ = 1);
            } while ((ae++ < ve || V[0] != null) && dt--);
            B = V[0] != null, et[0] || et.splice(0, 1);
          }
          if (d == p) {
            for (I = 1, dt = et[0]; dt >= 10; dt /= 10, I++)
              ;
            ht(Z, m + (Z.e = I + y * A - 1) + 1, x, B);
          } else
            Z.e = y, Z.r = +B;
          return Z;
        };
      }();
      function Ee(o, u, h, _) {
        var f, m, x, d, g;
        if (h == null ? h = W : Q(h, 0, 8), !o.c)
          return o.toString();
        if (f = o.c[0], x = o.e, u == null)
          g = N(o.c), g = _ == 1 || _ == 2 && (x <= st || x >= ut) ? j(g, x) : Y(g, x, "0");
        else if (o = ht(new v(o), u, h), m = o.e, g = N(o.c), d = g.length, _ == 1 || _ == 2 && (u <= m || m <= st)) {
          for (; d < u; g += "0", d++)
            ;
          g = j(g, m);
        } else if (u -= x, g = Y(g, m, "0"), m + 1 > d) {
          if (--u > 0)
            for (g += "."; u--; g += "0")
              ;
        } else if (u += m - d, u > 0)
          for (m + 1 == d && (g += "."); u--; g += "0")
            ;
        return o.s < 0 && f ? "-" + g : g;
      }
      function $e(o, u) {
        for (var h, _, f = 1, m = new v(o[0]); f < o.length; f++)
          _ = new v(o[f]), (!_.s || (h = T(m, _)) === u || h === 0 && m.s === u) && (m = _);
        return m;
      }
      function Se(o, u, h) {
        for (var _ = 1, f = u.length; !u[--f]; u.pop())
          ;
        for (f = u[0]; f >= 10; f /= 10, _++)
          ;
        return (h = _ + h * A - 1) > mt ? o.c = o.e = null : h < Ft ? o.c = [o.e = 0] : (o.e = h, o.c = u), o;
      }
      X = function() {
        var o = /^(-?)0([xbo])(?=\w[\w.]*$)/i, u = /^([^.]+)\.$/, h = /^\.([^.]+)$/, _ = /^-?(Infinity|NaN)$/, f = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(m, x, d, g) {
          var y, I = d ? x : x.replace(f, "");
          if (_.test(I))
            m.s = isNaN(I) ? null : I < 0 ? -1 : 1;
          else {
            if (!d && (I = I.replace(o, function(B, U, K) {
              return y = (K = K.toLowerCase()) == "x" ? 16 : K == "b" ? 2 : 8, !g || g == y ? U : B;
            }), g && (y = g, I = I.replace(u, "$1").replace(h, "0.$1")), x != I))
              return new v(I, y);
            if (v.DEBUG)
              throw Error(c + "Not a" + (g ? " base " + g : "") + " number: " + x);
            m.s = null;
          }
          m.c = m.e = null;
        };
      }();
      function ht(o, u, h, _) {
        var f, m, x, d, g, y, I, B = o.c, U = E;
        if (B) {
          t: {
            for (f = 1, d = B[0]; d >= 10; d /= 10, f++)
              ;
            if (m = u - f, m < 0)
              m += A, x = u, g = B[y = 0], I = a(g / U[f - x - 1] % 10);
            else if (y = n((m + 1) / A), y >= B.length)
              if (_) {
                for (; B.length <= y; B.push(0))
                  ;
                g = I = 0, f = 1, m %= A, x = m - A + 1;
              } else
                break t;
            else {
              for (g = d = B[y], f = 1; d >= 10; d /= 10, f++)
                ;
              m %= A, x = m - A + f, I = x < 0 ? 0 : a(g / U[f - x - 1] % 10);
            }
            if (_ = _ || u < 0 || B[y + 1] != null || (x < 0 ? g : g % U[f - x - 1]), _ = h < 4 ? (I || _) && (h == 0 || h == (o.s < 0 ? 3 : 2)) : I > 5 || I == 5 && (h == 4 || _ || h == 6 && (m > 0 ? x > 0 ? g / U[f - x] : 0 : B[y - 1]) % 10 & 1 || h == (o.s < 0 ? 8 : 7)), u < 1 || !B[0])
              return B.length = 0, _ ? (u -= o.e + 1, B[0] = U[(A - u % A) % A], o.e = -u || 0) : B[0] = o.e = 0, o;
            if (m == 0 ? (B.length = y, d = 1, y--) : (B.length = y + 1, d = U[A - m], B[y] = x > 0 ? a(g / U[f - x] % U[x]) * d : 0), _)
              for (; ; )
                if (y == 0) {
                  for (m = 1, x = B[0]; x >= 10; x /= 10, m++)
                    ;
                  for (x = B[0] += d, d = 1; x >= 10; x /= 10, d++)
                    ;
                  m != d && (o.e++, B[0] == p && (B[0] = 1));
                  break;
                } else {
                  if (B[y] += d, B[y] != p)
                    break;
                  B[y--] = 0, d = 1;
                }
            for (m = B.length; B[--m] === 0; B.pop())
              ;
          }
          o.e > mt ? o.c = o.e = null : o.e < Ft && (o.c = [o.e = 0]);
        }
        return o;
      }
      function Et(o) {
        var u, h = o.e;
        return h === null ? o.toString() : (u = N(o.c), u = h <= st || h >= ut ? j(u, h) : Y(u, h, "0"), o.s < 0 ? "-" + u : u);
      }
      return D.absoluteValue = D.abs = function() {
        var o = new v(this);
        return o.s < 0 && (o.s = 1), o;
      }, D.comparedTo = function(o, u) {
        return T(this, new v(o, u));
      }, D.decimalPlaces = D.dp = function(o, u) {
        var h, _, f, m = this;
        if (o != null)
          return Q(o, 0, b), u == null ? u = W : Q(u, 0, 8), ht(new v(m), o + m.e + 1, u);
        if (!(h = m.c))
          return null;
        if (_ = ((f = h.length - 1) - k(this.e / A)) * A, f = h[f])
          for (; f % 10 == 0; f /= 10, _--)
            ;
        return _ < 0 && (_ = 0), _;
      }, D.dividedBy = D.div = function(o, u) {
        return M(this, new v(o, u), q, W);
      }, D.dividedToIntegerBy = D.idiv = function(o, u) {
        return M(this, new v(o, u), 0, 1);
      }, D.exponentiatedBy = D.pow = function(o, u) {
        var h, _, f, m, x, d, g, y, I, B = this;
        if (o = new v(o), o.c && !o.isInteger())
          throw Error(c + "Exponent not an integer: " + Et(o));
        if (u != null && (u = new v(u)), d = o.e > 14, !B.c || !B.c[0] || B.c[0] == 1 && !B.e && B.c.length == 1 || !o.c || !o.c[0])
          return I = new v(Math.pow(+Et(B), d ? o.s * (2 - R(o)) : +Et(o))), u ? I.mod(u) : I;
        if (g = o.s < 0, u) {
          if (u.c ? !u.c[0] : !u.s)
            return new v(NaN);
          _ = !g && B.isInteger() && u.isInteger(), _ && (B = B.mod(u));
        } else {
          if (o.e > 9 && (B.e > 0 || B.e < -1 || (B.e == 0 ? B.c[0] > 1 || d && B.c[1] >= 24e7 : B.c[0] < 8e13 || d && B.c[0] <= 9999975e7)))
            return m = B.s < 0 && R(o) ? -0 : 0, B.e > -1 && (m = 1 / m), new v(g ? 1 / m : m);
          kt && (m = n(kt / A + 2));
        }
        for (d ? (h = new v(0.5), g && (o.s = 1), y = R(o)) : (f = Math.abs(+Et(o)), y = f % 2), I = new v(F); ; ) {
          if (y) {
            if (I = I.times(B), !I.c)
              break;
            m ? I.c.length > m && (I.c.length = m) : _ && (I = I.mod(u));
          }
          if (f) {
            if (f = a(f / 2), f === 0)
              break;
            y = f % 2;
          } else if (o = o.times(h), ht(o, o.e + 1, 1), o.e > 14)
            y = R(o);
          else {
            if (f = +Et(o), f === 0)
              break;
            y = f % 2;
          }
          B = B.times(B), m ? B.c && B.c.length > m && (B.c.length = m) : _ && (B = B.mod(u));
        }
        return _ ? I : (g && (I = F.div(I)), u ? I.mod(u) : m ? ht(I, kt, W, x) : I);
      }, D.integerValue = function(o) {
        var u = new v(this);
        return o == null ? o = W : Q(o, 0, 8), ht(u, u.e + 1, o);
      }, D.isEqualTo = D.eq = function(o, u) {
        return T(this, new v(o, u)) === 0;
      }, D.isFinite = function() {
        return !!this.c;
      }, D.isGreaterThan = D.gt = function(o, u) {
        return T(this, new v(o, u)) > 0;
      }, D.isGreaterThanOrEqualTo = D.gte = function(o, u) {
        return (u = T(this, new v(o, u))) === 1 || u === 0;
      }, D.isInteger = function() {
        return !!this.c && k(this.e / A) > this.c.length - 2;
      }, D.isLessThan = D.lt = function(o, u) {
        return T(this, new v(o, u)) < 0;
      }, D.isLessThanOrEqualTo = D.lte = function(o, u) {
        return (u = T(this, new v(o, u))) === -1 || u === 0;
      }, D.isNaN = function() {
        return !this.s;
      }, D.isNegative = function() {
        return this.s < 0;
      }, D.isPositive = function() {
        return this.s > 0;
      }, D.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, D.minus = function(o, u) {
        var h, _, f, m, x = this, d = x.s;
        if (o = new v(o, u), u = o.s, !d || !u)
          return new v(NaN);
        if (d != u)
          return o.s = -u, x.plus(o);
        var g = x.e / A, y = o.e / A, I = x.c, B = o.c;
        if (!g || !y) {
          if (!I || !B)
            return I ? (o.s = -u, o) : new v(B ? x : NaN);
          if (!I[0] || !B[0])
            return B[0] ? (o.s = -u, o) : new v(I[0] ? x : W == 3 ? -0 : 0);
        }
        if (g = k(g), y = k(y), I = I.slice(), d = g - y) {
          for ((m = d < 0) ? (d = -d, f = I) : (y = g, f = B), f.reverse(), u = d; u--; f.push(0))
            ;
          f.reverse();
        } else
          for (_ = (m = (d = I.length) < (u = B.length)) ? d : u, d = u = 0; u < _; u++)
            if (I[u] != B[u]) {
              m = I[u] < B[u];
              break;
            }
        if (m && (f = I, I = B, B = f, o.s = -o.s), u = (_ = B.length) - (h = I.length), u > 0)
          for (; u--; I[h++] = 0)
            ;
        for (u = p - 1; _ > d; ) {
          if (I[--_] < B[_]) {
            for (h = _; h && !I[--h]; I[h] = u)
              ;
            --I[h], I[_] += p;
          }
          I[_] -= B[_];
        }
        for (; I[0] == 0; I.splice(0, 1), --y)
          ;
        return I[0] ? Se(o, I, y) : (o.s = W == 3 ? -1 : 1, o.c = [o.e = 0], o);
      }, D.modulo = D.mod = function(o, u) {
        var h, _, f = this;
        return o = new v(o, u), !f.c || !o.s || o.c && !o.c[0] ? new v(NaN) : !o.c || f.c && !f.c[0] ? new v(f) : (Zt == 9 ? (_ = o.s, o.s = 1, h = M(f, o, 0, 3), o.s = _, h.s *= _) : h = M(f, o, 0, Zt), o = f.minus(h.times(o)), !o.c[0] && Zt == 1 && (o.s = f.s), o);
      }, D.multipliedBy = D.times = function(o, u) {
        var h, _, f, m, x, d, g, y, I, B, U, K, L, Z, et, V = this, $ = V.c, nt = (o = new v(o, u)).c;
        if (!$ || !nt || !$[0] || !nt[0])
          return !V.s || !o.s || $ && !$[0] && !nt || nt && !nt[0] && !$ ? o.c = o.e = o.s = null : (o.s *= V.s, !$ || !nt ? o.c = o.e = null : (o.c = [0], o.e = 0)), o;
        for (_ = k(V.e / A) + k(o.e / A), o.s *= V.s, g = $.length, B = nt.length, g < B && (L = $, $ = nt, nt = L, f = g, g = B, B = f), f = g + B, L = []; f--; L.push(0))
          ;
        for (Z = p, et = w, f = B; --f >= 0; ) {
          for (h = 0, U = nt[f] % et, K = nt[f] / et | 0, x = g, m = f + x; m > f; )
            y = $[--x] % et, I = $[x] / et | 0, d = K * y + I * U, y = U * y + d % et * et + L[m] + h, h = (y / Z | 0) + (d / et | 0) + K * I, L[m--] = y % Z;
          L[m] = h;
        }
        return h ? ++_ : L.splice(0, 1), Se(o, L, _);
      }, D.negated = function() {
        var o = new v(this);
        return o.s = -o.s || null, o;
      }, D.plus = function(o, u) {
        var h, _ = this, f = _.s;
        if (o = new v(o, u), u = o.s, !f || !u)
          return new v(NaN);
        if (f != u)
          return o.s = -u, _.minus(o);
        var m = _.e / A, x = o.e / A, d = _.c, g = o.c;
        if (!m || !x) {
          if (!d || !g)
            return new v(f / 0);
          if (!d[0] || !g[0])
            return g[0] ? o : new v(d[0] ? _ : f * 0);
        }
        if (m = k(m), x = k(x), d = d.slice(), f = m - x) {
          for (f > 0 ? (x = m, h = g) : (f = -f, h = d), h.reverse(); f--; h.push(0))
            ;
          h.reverse();
        }
        for (f = d.length, u = g.length, f - u < 0 && (h = g, g = d, d = h, u = f), f = 0; u; )
          f = (d[--u] = d[u] + g[u] + f) / p | 0, d[u] = p === d[u] ? 0 : d[u] % p;
        return f && (d = [f].concat(d), ++x), Se(o, d, x);
      }, D.precision = D.sd = function(o, u) {
        var h, _, f, m = this;
        if (o != null && o !== !!o)
          return Q(o, 1, b), u == null ? u = W : Q(u, 0, 8), ht(new v(m), o, u);
        if (!(h = m.c))
          return null;
        if (f = h.length - 1, _ = f * A + 1, f = h[f]) {
          for (; f % 10 == 0; f /= 10, _--)
            ;
          for (f = h[0]; f >= 10; f /= 10, _++)
            ;
        }
        return o && m.e + 1 > _ && (_ = m.e + 1), _;
      }, D.shiftedBy = function(o) {
        return Q(o, -C, C), this.times("1e" + o);
      }, D.squareRoot = D.sqrt = function() {
        var o, u, h, _, f, m = this, x = m.c, d = m.s, g = m.e, y = q + 4, I = new v("0.5");
        if (d !== 1 || !x || !x[0])
          return new v(!d || d < 0 && (!x || x[0]) ? NaN : x ? m : 1 / 0);
        if (d = Math.sqrt(+Et(m)), d == 0 || d == 1 / 0 ? (u = N(x), (u.length + g) % 2 == 0 && (u += "0"), d = Math.sqrt(+u), g = k((g + 1) / 2) - (g < 0 || g % 2), d == 1 / 0 ? u = "5e" + g : (u = d.toExponential(), u = u.slice(0, u.indexOf("e") + 1) + g), h = new v(u)) : h = new v(d + ""), h.c[0]) {
          for (g = h.e, d = g + y, d < 3 && (d = 0); ; )
            if (f = h, h = I.times(f.plus(M(m, f, y, 1))), N(f.c).slice(0, d) === (u = N(h.c)).slice(0, d))
              if (h.e < g && --d, u = u.slice(d - 3, d + 1), u == "9999" || !_ && u == "4999") {
                if (!_ && (ht(f, f.e + q + 2, 0), f.times(f).eq(m))) {
                  h = f;
                  break;
                }
                y += 4, d += 4, _ = 1;
              } else {
                (!+u || !+u.slice(1) && u.charAt(0) == "5") && (ht(h, h.e + q + 2, 1), o = !h.times(h).eq(m));
                break;
              }
        }
        return ht(h, h.e + q + 1, W, o);
      }, D.toExponential = function(o, u) {
        return o != null && (Q(o, 0, b), o++), Ee(this, o, u, 1);
      }, D.toFixed = function(o, u) {
        return o != null && (Q(o, 0, b), o = o + this.e + 1), Ee(this, o, u);
      }, D.toFormat = function(o, u, h) {
        var _, f = this;
        if (h == null)
          o != null && u && typeof u == "object" ? (h = u, u = null) : o && typeof o == "object" ? (h = o, o = u = null) : h = Ce;
        else if (typeof h != "object")
          throw Error(c + "Argument not an object: " + h);
        if (_ = f.toFixed(o, u), f.c) {
          var m, x = _.split("."), d = +h.groupSize, g = +h.secondaryGroupSize, y = h.groupSeparator || "", I = x[0], B = x[1], U = f.s < 0, K = U ? I.slice(1) : I, L = K.length;
          if (g && (m = d, d = g, g = m, L -= m), d > 0 && L > 0) {
            for (m = L % d || d, I = K.substr(0, m); m < L; m += d)
              I += y + K.substr(m, d);
            g > 0 && (I += y + K.slice(m)), U && (I = "-" + I);
          }
          _ = B ? I + (h.decimalSeparator || "") + ((g = +h.fractionGroupSize) ? B.replace(
            new RegExp("\\d{" + g + "}\\B", "g"),
            "$&" + (h.fractionGroupSeparator || "")
          ) : B) : I;
        }
        return (h.prefix || "") + _ + (h.suffix || "");
      }, D.toFraction = function(o) {
        var u, h, _, f, m, x, d, g, y, I, B, U, K = this, L = K.c;
        if (o != null && (d = new v(o), !d.isInteger() && (d.c || d.s !== 1) || d.lt(F)))
          throw Error(c + "Argument " + (d.isInteger() ? "out of range: " : "not an integer: ") + Et(d));
        if (!L)
          return new v(K);
        for (u = new v(F), y = h = new v(F), _ = g = new v(F), U = N(L), m = u.e = U.length - K.e - 1, u.c[0] = E[(x = m % A) < 0 ? A + x : x], o = !o || d.comparedTo(u) > 0 ? m > 0 ? u : y : d, x = mt, mt = 1 / 0, d = new v(U), g.c[0] = 0; I = M(d, u, 0, 1), f = h.plus(I.times(_)), f.comparedTo(o) != 1; )
          h = _, _ = f, y = g.plus(I.times(f = y)), g = f, u = d.minus(I.times(f = u)), d = f;
        return f = M(o.minus(h), _, 0, 1), g = g.plus(f.times(y)), h = h.plus(f.times(_)), g.s = y.s = K.s, m = m * 2, B = M(y, _, m, W).minus(K).abs().comparedTo(
          M(g, h, m, W).minus(K).abs()
        ) < 1 ? [y, _] : [g, h], mt = x, B;
      }, D.toNumber = function() {
        return +Et(this);
      }, D.toPrecision = function(o, u) {
        return o != null && Q(o, 1, b), Ee(this, o, u, 2);
      }, D.toString = function(o) {
        var u, h = this, _ = h.s, f = h.e;
        return f === null ? _ ? (u = "Infinity", _ < 0 && (u = "-" + u)) : u = "NaN" : (o == null ? u = f <= st || f >= ut ? j(N(h.c), f) : Y(N(h.c), f, "0") : o === 10 && Be ? (h = ht(new v(h), q + f + 1, W), u = Y(N(h.c), h.e, "0")) : (Q(o, 2, qt.length, "Base"), u = z(Y(N(h.c), f, "0"), 10, o, _, !0)), _ < 0 && h.c[0] && (u = "-" + u)), u;
      }, D.valueOf = D.toJSON = function() {
        return Et(this);
      }, D._isBigNumber = !0, O != null && v.set(O), v;
    }
    function k(O) {
      var M = O | 0;
      return O > 0 || O === M ? M : M - 1;
    }
    function N(O) {
      for (var M, z, X = 1, D = O.length, F = O[0] + ""; X < D; ) {
        for (M = O[X++] + "", z = A - M.length; z--; M = "0" + M)
          ;
        F += M;
      }
      for (D = F.length; F.charCodeAt(--D) === 48; )
        ;
      return F.slice(0, D + 1 || 1);
    }
    function T(O, M) {
      var z, X, D = O.c, F = M.c, q = O.s, W = M.s, st = O.e, ut = M.e;
      if (!q || !W)
        return null;
      if (z = D && !D[0], X = F && !F[0], z || X)
        return z ? X ? 0 : -W : q;
      if (q != W)
        return q;
      if (z = q < 0, X = st == ut, !D || !F)
        return X ? 0 : !D ^ z ? 1 : -1;
      if (!X)
        return st > ut ^ z ? 1 : -1;
      for (W = (st = D.length) < (ut = F.length) ? st : ut, q = 0; q < W; q++)
        if (D[q] != F[q])
          return D[q] > F[q] ^ z ? 1 : -1;
      return st == ut ? 0 : st > ut ^ z ? 1 : -1;
    }
    function Q(O, M, z, X) {
      if (O < M || O > z || O !== a(O))
        throw Error(c + (X || "Argument") + (typeof O == "number" ? O < M || O > z ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(O));
    }
    function R(O) {
      var M = O.c.length - 1;
      return k(O.e / A) == M && O.c[M] % 2 != 0;
    }
    function j(O, M) {
      return (O.length > 1 ? O.charAt(0) + "." + O.slice(1) : O) + (M < 0 ? "e" : "e+") + M;
    }
    function Y(O, M, z) {
      var X, D;
      if (M < 0) {
        for (D = z + "."; ++M; D += z)
          ;
        O = D + O;
      } else if (X = O.length, ++M > X) {
        for (D = z, M -= X; --M; D += z)
          ;
        O += D;
      } else
        M < X && (O = O.slice(0, M) + "." + O.slice(M));
      return O;
    }
    t = P(), t.default = t.BigNumber = t, s.exports ? s.exports = t : (e || (e = typeof self < "u" && self ? self : window), e.BigNumber = t);
  })(Ne);
})(Ye);
(function(s) {
  var e = Ye.exports, t = s.exports;
  (function() {
    var r = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, n, a, c = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, l;
    function p(C) {
      return r.lastIndex = 0, r.test(C) ? '"' + C.replace(r, function(E) {
        var w = c[E];
        return typeof w == "string" ? w : "\\u" + ("0000" + E.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + C + '"';
    }
    function A(C, E) {
      var w, b, P, k, N = n, T, Q = E[C], R = Q != null && (Q instanceof e || e.isBigNumber(Q));
      switch (Q && typeof Q == "object" && typeof Q.toJSON == "function" && (Q = Q.toJSON(C)), typeof l == "function" && (Q = l.call(E, C, Q)), typeof Q) {
        case "string":
          return R ? Q : p(Q);
        case "number":
          return isFinite(Q) ? String(Q) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(Q);
        case "object":
          if (!Q)
            return "null";
          if (n += a, T = [], Object.prototype.toString.apply(Q) === "[object Array]") {
            for (k = Q.length, w = 0; w < k; w += 1)
              T[w] = A(w, Q) || "null";
            return P = T.length === 0 ? "[]" : n ? `[
` + n + T.join(`,
` + n) + `
` + N + "]" : "[" + T.join(",") + "]", n = N, P;
          }
          if (l && typeof l == "object")
            for (k = l.length, w = 0; w < k; w += 1)
              typeof l[w] == "string" && (b = l[w], P = A(b, Q), P && T.push(p(b) + (n ? ": " : ":") + P));
          else
            Object.keys(Q).forEach(function(j) {
              var Y = A(j, Q);
              Y && T.push(p(j) + (n ? ": " : ":") + Y);
            });
          return P = T.length === 0 ? "{}" : n ? `{
` + n + T.join(`,
` + n) + `
` + N + "}" : "{" + T.join(",") + "}", n = N, P;
      }
    }
    typeof t.stringify != "function" && (t.stringify = function(C, E, w) {
      var b;
      if (n = "", a = "", typeof w == "number")
        for (b = 0; b < w; b += 1)
          a += " ";
      else
        typeof w == "string" && (a = w);
      if (l = E, E && typeof E != "function" && (typeof E != "object" || typeof E.length != "number"))
        throw new Error("JSON.stringify");
      return A("", { "": C });
    });
  })();
})(Rr);
var he = null;
const Js = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/, Ws = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
var js = function(s) {
  var e = {
    strict: !1,
    storeAsString: !1,
    alwaysParseAsBig: !1,
    useNativeBigInt: !1,
    protoAction: "error",
    constructorAction: "error"
  };
  if (s != null) {
    if (s.strict === !0 && (e.strict = !0), s.storeAsString === !0 && (e.storeAsString = !0), e.alwaysParseAsBig = s.alwaysParseAsBig === !0 ? s.alwaysParseAsBig : !1, e.useNativeBigInt = s.useNativeBigInt === !0 ? s.useNativeBigInt : !1, typeof s.constructorAction < "u")
      if (s.constructorAction === "error" || s.constructorAction === "ignore" || s.constructorAction === "preserve")
        e.constructorAction = s.constructorAction;
      else
        throw new Error(
          `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${s.constructorAction}`
        );
    if (typeof s.protoAction < "u")
      if (s.protoAction === "error" || s.protoAction === "ignore" || s.protoAction === "preserve")
        e.protoAction = s.protoAction;
      else
        throw new Error(
          `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${s.protoAction}`
        );
  }
  var t, r, n = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "	"
  }, a, c = function(k) {
    throw {
      name: "SyntaxError",
      message: k,
      at: t,
      text: a
    };
  }, l = function(k) {
    return k && k !== r && c("Expected '" + k + "' instead of '" + r + "'"), r = a.charAt(t), t += 1, r;
  }, p = function() {
    var k, N = "";
    for (r === "-" && (N = "-", l("-")); r >= "0" && r <= "9"; )
      N += r, l();
    if (r === ".")
      for (N += "."; l() && r >= "0" && r <= "9"; )
        N += r;
    if (r === "e" || r === "E")
      for (N += r, l(), (r === "-" || r === "+") && (N += r, l()); r >= "0" && r <= "9"; )
        N += r, l();
    if (k = +N, !isFinite(k))
      c("Bad number");
    else
      return he == null && (he = Ye.exports), N.length > 15 ? e.storeAsString ? N : e.useNativeBigInt ? BigInt(N) : new he(N) : e.alwaysParseAsBig ? e.useNativeBigInt ? BigInt(k) : new he(k) : k;
  }, A = function() {
    var k, N, T = "", Q;
    if (r === '"')
      for (var R = t; l(); ) {
        if (r === '"')
          return t - 1 > R && (T += a.substring(R, t - 1)), l(), T;
        if (r === "\\") {
          if (t - 1 > R && (T += a.substring(R, t - 1)), l(), r === "u") {
            for (Q = 0, N = 0; N < 4 && (k = parseInt(l(), 16), !!isFinite(k)); N += 1)
              Q = Q * 16 + k;
            T += String.fromCharCode(Q);
          } else if (typeof n[r] == "string")
            T += n[r];
          else
            break;
          R = t;
        }
      }
    c("Bad string");
  }, C = function() {
    for (; r && r <= " "; )
      l();
  }, E = function() {
    switch (r) {
      case "t":
        return l("t"), l("r"), l("u"), l("e"), !0;
      case "f":
        return l("f"), l("a"), l("l"), l("s"), l("e"), !1;
      case "n":
        return l("n"), l("u"), l("l"), l("l"), null;
    }
    c("Unexpected '" + r + "'");
  }, w, b = function() {
    var k = [];
    if (r === "[") {
      if (l("["), C(), r === "]")
        return l("]"), k;
      for (; r; ) {
        if (k.push(w()), C(), r === "]")
          return l("]"), k;
        l(","), C();
      }
    }
    c("Bad array");
  }, P = function() {
    var k, N = /* @__PURE__ */ Object.create(null);
    if (r === "{") {
      if (l("{"), C(), r === "}")
        return l("}"), N;
      for (; r; ) {
        if (k = A(), C(), l(":"), e.strict === !0 && Object.hasOwnProperty.call(N, k) && c('Duplicate key "' + k + '"'), Js.test(k) === !0 ? e.protoAction === "error" ? c("Object contains forbidden prototype property") : e.protoAction === "ignore" ? w() : N[k] = w() : Ws.test(k) === !0 ? e.constructorAction === "error" ? c("Object contains forbidden constructor property") : e.constructorAction === "ignore" ? w() : N[k] = w() : N[k] = w(), C(), r === "}")
          return l("}"), N;
        l(","), C();
      }
    }
    c("Bad object");
  };
  return w = function() {
    switch (C(), r) {
      case "{":
        return P();
      case "[":
        return b();
      case '"':
        return A();
      case "-":
        return p();
      default:
        return r >= "0" && r <= "9" ? p() : E();
    }
  }, function(k, N) {
    var T;
    return a = k + "", t = 0, r = " ", T = w(), C(), r && c("Syntax error"), typeof N == "function" ? function Q(R, j) {
      var Y, O = R[j];
      return O && typeof O == "object" && Object.keys(O).forEach(function(M) {
        Y = Q(O, M), Y !== void 0 ? O[M] = Y : delete O[M];
      }), N.call(R, j, O);
    }({ "": T }, "") : T;
  };
}, Xs = js, qr = Rr.exports.stringify, Vr = Xs;
zt.exports = function(s) {
  return {
    parse: Vr(s),
    stringify: qr
  };
};
zt.exports.parse = Vr();
zt.exports.stringify = qr;
class Zs {
  txHex = "";
  txBuilder = me();
  txEvaluationMultiplier = 1.1;
  _protocolParams = ft;
  txOutput;
  addingScriptInput = !1;
  addingPlutusMint = !1;
  isHydra = !1;
  meshTxBuilderBody;
  mintItem;
  txInQueueItem;
  collateralQueueItem;
  refScriptTxInQueueItem;
  reset = () => (this.txHex = "", this.txBuilder = me(), this.txEvaluationMultiplier = 1.1, this._protocolParams = ft, this.txOutput = void 0, this.addingScriptInput = !1, this.addingPlutusMint = !1, this.mintItem = void 0, this.txInQueueItem = void 0, this.collateralQueueItem = void 0, this.refScriptTxInQueueItem = void 0, this.meshTxBuilderBody = this.emptyTxBuilderBody(), this);
  emptyTxBuilderBody = () => ({
    inputs: [],
    outputs: [],
    extraInputs: [],
    selectionThreshold: 0,
    collaterals: [],
    requiredSignatures: [],
    referenceInputs: [],
    mints: [],
    changeAddress: "",
    metadata: [],
    validityRange: {},
    certificates: [],
    signingKey: []
  });
  constructor() {
    this.meshTxBuilderBody = this.emptyTxBuilderBody();
  }
  completeSync = (e) => (e ? this.meshTxBuilderBody = e : this.queueAllLastItem(), this.serializeTxBody(this.meshTxBuilderBody));
  completeSigning = () => {
    const { signingKey: e } = this.meshTxBuilderBody;
    return e.length > 0 && this.addAllSigningKeys(e), this.txHex;
  };
  serializeTxBody = (e) => {
    const { inputs: t, outputs: r, extraInputs: n, selectionThreshold: a, collaterals: c, referenceInputs: l, mints: p, changeAddress: A, certificates: C, validityRange: E, requiredSignatures: w, metadata: b } = e;
    if (this.isHydra ? this.protocolParams({
      minFeeA: 0,
      minFeeB: 0,
      priceMem: 0,
      priceStep: 0,
      collateralPercent: 0,
      coinsPerUTxOSize: "0"
    }) : this.protocolParams({}), n.length > 0 && this.addUtxosFrom(n, String(a)), this.removeDuplicateInputs(), this.meshTxBuilderBody.mints.sort((P, k) => P.policyId.localeCompare(k.policyId)), this.meshTxBuilderBody.inputs.sort((P, k) => P.txIn.txHash === k.txIn.txHash ? P.txIn.txIndex - k.txIn.txIndex : P.txIn.txHash.localeCompare(k.txIn.txHash)), this.addAllInputs(t), this.addAllOutputs(r), this.addAllCollaterals(c), this.addAllReferenceInputs(l), this.addAllMints(p), this.addAllCertificates(C), this.addValidityRange(E), this.addAllRequiredSignatures(w), this.addAllMetadata(b), this.addCostModels(), A) {
      const P = this.meshTxBuilderBody.collaterals.map((T) => {
        var Q, R;
        return ((R = (Q = T.txIn.amount) == null ? void 0 : Q.find((j) => j.unit === "lovelace")) == null ? void 0 : R.quantity) || "0";
      }).reduce((T, Q) => T + parseInt(Q), 0), k = Math.ceil(this._protocolParams.collateralPercent * Number(Number(this.txBuilder.min_fee().checked_add(i.BigNum.from_str("10000")).to_js_value())) / 100);
      let N = !1;
      if (P - k > 0) {
        const T = i.TransactionOutput.new(i.Address.from_bech32(A), i.Value.new(i.BigNum.from_str(String(k))));
        P - k > Number(i.min_ada_for_output(T, i.DataCost.new_coins_per_byte(i.BigNum.from_str(this._protocolParams.coinsPerUTxOSize))).to_js_value()) && (this.txBuilder.set_collateral_return(i.TransactionOutput.new(i.Address.from_bech32(A), i.Value.new(i.BigNum.from_str(String(P))))), this.txBuilder.set_total_collateral(i.BigNum.from_str(String(P))), N = !0);
      }
      this.addChange(A), N && this.addCollateralReturn(A);
    }
    return this.buildTx(), this;
  };
  txIn = (e, t, r, n) => (this.txInQueueItem && this.queueInput(), this.addingScriptInput ? this.txInQueueItem = {
    type: "Script",
    txIn: {
      txHash: e,
      txIndex: t,
      amount: r,
      address: n
    },
    scriptTxIn: {}
  } : this.txInQueueItem = {
    type: "PubKey",
    txIn: {
      txHash: e,
      txIndex: t,
      amount: r,
      address: n
    }
  }, this.addingScriptInput = !1, this);
  txInScript = (e, t = "V2") => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Datum value attempted to be called a non script input");
    return this.txInQueueItem.scriptTxIn.scriptSource = {
      type: "Provided",
      script: {
        code: e,
        version: t
      }
    }, this;
  };
  txInDatumValue = (e, t = "Mesh") => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Datum value attempted to be called a non script input");
    let r = e;
    return t === "JSON" && (r = this.castRawDataToJsonString(e)), t === "Mesh" ? (this.txInQueueItem.scriptTxIn.datumSource = {
      type: "Provided",
      data: {
        type: t,
        content: e
      }
    }, this) : (this.txInQueueItem.scriptTxIn.datumSource = {
      type: "Provided",
      data: {
        type: t,
        content: r
      }
    }, this);
  };
  txInInlineDatumPresent = () => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Inline datum present attempted to be called a non script input");
    const { txHash: e, txIndex: t } = this.txInQueueItem.txIn;
    return e && t.toString() && (this.txInQueueItem.scriptTxIn.datumSource = {
      type: "Inline",
      txHash: e,
      txIndex: t
    }), this;
  };
  txInRedeemerValue = (e, t = { ...Gt }, r = "Mesh") => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Spending tx in reference redeemer attempted to be called a non script input");
    let n = e;
    return r === "Mesh" ? (this.txInQueueItem.scriptTxIn.redeemer = {
      data: {
        type: r,
        content: e
      },
      exUnits: t
    }, this) : (r === "JSON" && (n = this.castRawDataToJsonString(e)), this.txInQueueItem.scriptTxIn.redeemer = {
      data: {
        type: r,
        content: n
      },
      exUnits: t
    }, this);
  };
  txOut = (e, t) => (this.txOutput && (this.meshTxBuilderBody.outputs.push(this.txOutput), this.txOutput = void 0), this.txOutput = {
    address: e,
    amount: t
  }, this);
  txOutDatumHashValue = (e, t = "Mesh") => {
    let r = e;
    if (this.txOutput) {
      if (t === "Mesh")
        return this.txOutput.datum = {
          type: "Hash",
          data: {
            type: t,
            content: r
          }
        }, this;
      t === "JSON" && (r = this.castRawDataToJsonString(e)), this.txOutput.datum = {
        type: "Hash",
        data: {
          type: t,
          content: r
        }
      };
    }
    return this;
  };
  txOutInlineDatumValue = (e, t = "Mesh") => {
    let r = e;
    if (this.txOutput) {
      if (t === "Mesh")
        return this.txOutput.datum = {
          type: "Inline",
          data: {
            type: t,
            content: r
          }
        }, this;
      t === "JSON" && (r = this.castRawDataToJsonString(e)), this.txOutput.datum = {
        type: "Inline",
        data: {
          type: t,
          content: r
        }
      };
    }
    return this;
  };
  txOutReferenceScript = (e, t = "V2") => (this.txOutput && (this.txOutput.referenceScript = { code: e, version: t }), this);
  spendingPlutusScriptV2 = () => (this.addingScriptInput = !0, this);
  spendingTxInReference = (e, t, r, n = "V2") => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Spending tx in reference attempted to be called a non script input");
    return this.txInQueueItem.scriptTxIn.scriptSource = {
      type: "Inline",
      txInInfo: {
        txHash: e,
        txIndex: t,
        spendingScriptHash: r,
        version: n
      }
    }, this;
  };
  spendingReferenceTxInInlineDatumPresent = () => (this.txInInlineDatumPresent(), this);
  spendingReferenceTxInRedeemerValue = (e, t = { ...Gt }, r = "Mesh") => (this.txInRedeemerValue(e, t, r), this);
  readOnlyTxInReference = (e, t) => (this.meshTxBuilderBody.referenceInputs.push({ txHash: e, txIndex: t }), this);
  mintPlutusScriptV2 = () => (this.addingPlutusMint = !0, this);
  mint = (e, t, r) => (this.mintItem && this.queueMint(), this.mintItem = {
    type: this.addingPlutusMint ? "Plutus" : "Native",
    policyId: t,
    assetName: r,
    amount: e
  }, this.addingPlutusMint = !1, this);
  mintingScript = (e, t = "V2") => {
    if (!this.mintItem)
      throw Error("Undefined mint");
    if (!this.mintItem.type)
      throw Error("Mint information missing");
    return this.mintItem.scriptSource = {
      type: "Provided",
      script: { code: e, version: t }
    }, this;
  };
  mintTxInReference = (e, t, r = "V2") => {
    if (!this.mintItem)
      throw Error("Undefined mint");
    if (!this.mintItem.type)
      throw Error("Mint information missing");
    if (this.mintItem.type == "Native")
      throw Error("Mint tx in reference can only be used on plutus script tokens");
    if (!this.mintItem.policyId)
      throw Error("PolicyId information missing from mint asset");
    return this.mintItem.scriptSource = {
      type: "Reference Script",
      txHash: e,
      txIndex: t,
      version: r
    }, this;
  };
  mintReferenceTxInRedeemerValue = (e, t = { ...Gt }, r = "Mesh") => {
    if (!this.mintItem)
      throw Error("Undefined mint");
    if (this.mintItem.type == "Native")
      throw Error("Mint tx in reference can only be used on plutus script tokens");
    if (this.mintItem.type == "Plutus") {
      if (!this.mintItem.policyId)
        throw Error("PolicyId information missing from mint asset");
      let n = e;
      if (r === "Mesh")
        return this.mintItem.redeemer = {
          data: {
            type: r,
            content: n
          },
          exUnits: t
        }, this;
      r === "JSON" && (n = this.castRawDataToJsonString(e)), this.mintItem.redeemer = {
        data: {
          type: r,
          content: n
        },
        exUnits: t
      };
    }
    return this;
  };
  mintRedeemerValue = (e, t = { ...Gt }, r = "Mesh") => (this.mintReferenceTxInRedeemerValue(e, t, r), this);
  requiredSignerHash = (e) => (this.meshTxBuilderBody.requiredSignatures.push(e), this);
  txInCollateral = (e, t, r, n) => (this.collateralQueueItem && this.meshTxBuilderBody.collaterals.push(this.collateralQueueItem), this.collateralQueueItem = {
    type: "PubKey",
    txIn: {
      txHash: e,
      txIndex: t,
      amount: r,
      address: n
    }
  }, this);
  registerPoolCertificate = (e) => (this.meshTxBuilderBody.certificates.push({
    type: "RegisterPool",
    poolParams: e
  }), this);
  registerStakeCertificate = (e) => (this.meshTxBuilderBody.certificates.push({
    type: "RegisterStake",
    stakeKeyHash: e
  }), this);
  delegateStakeCertificate = (e, t) => (this.meshTxBuilderBody.certificates.push({
    type: "DelegateStake",
    stakeKeyHash: e,
    poolId: t
  }), this);
  deregisterStakeCertificate = (e) => (this.meshTxBuilderBody.certificates.push({
    type: "DeregisterStake",
    stakeKeyHash: e
  }), this);
  retirePoolCertificate = (e, t) => (this.meshTxBuilderBody.certificates.push({
    type: "RetirePool",
    poolId: e,
    epoch: t
  }), this);
  changeAddress = (e) => (this.meshTxBuilderBody.changeAddress = e, this);
  invalidBefore = (e) => (this.meshTxBuilderBody.validityRange.invalidBefore = e, this);
  invalidHereafter = (e) => (this.meshTxBuilderBody.validityRange.invalidHereafter = e, this);
  metadataValue = (e, t) => (this.meshTxBuilderBody.metadata.push({ tag: e, metadata: t }), this);
  protocolParams = (e) => {
    const t = { ...ft, ...e };
    return this._protocolParams = t, this.txBuilder = me(t), this;
  };
  signingKey = (e) => (this.meshTxBuilderBody.signingKey.push(e), this);
  selectUtxosFrom = (e, t = 5e6) => (this.meshTxBuilderBody.extraInputs = e, this.meshTxBuilderBody.selectionThreshold = t, this);
  addUtxosFrom = (e, t) => {
    const r = this.meshTxBuilderBody.outputs.reduce((a, c) => (c.amount.forEach((p) => {
      const { unit: A, quantity: C } = p, E = Number(a.get(A)) || 0;
      a.set(A, String(E + Number(C)));
    }), a), /* @__PURE__ */ new Map());
    this.meshTxBuilderBody.inputs.reduce((a, c) => {
      const l = c.txIn.amount;
      return l == null || l.forEach((p) => {
        const { unit: A, quantity: C } = p, E = Number(a.get(A)) || 0;
        a.set(A, String(E - Number(C)));
      }), a;
    }, r), this.meshTxBuilderBody.mints.reduce((a, c) => {
      const l = {
        unit: c.policyId + c.assetName,
        quantity: String(c.amount)
      }, p = Number(a.get(l.unit)) || 0;
      return a.set(l.unit, String(p - Number(l.quantity))), a;
    }, r), $s(e, r, t).forEach((a) => {
      this.addTxIn({
        type: "PubKey",
        txIn: {
          txHash: a.input.txHash,
          txIndex: a.input.outputIndex,
          amount: a.output.amount,
          address: a.output.address
        }
      });
    });
  };
  addAllSigningKeys = (e) => {
    if (e.length > 0) {
      const t = i.Vkeywitnesses.new(), r = i.Transaction.from_hex(this.txHex), n = r.body();
      e.forEach((l) => {
        const p = l.slice(0, 4) === "5820" ? l.slice(4) : l, A = i.PrivateKey.from_hex(p), C = i.make_vkey_witness(i.hash_transaction(n), A);
        t.add(C);
      });
      const a = r.witness_set();
      a.set_vkeys(t);
      const c = i.Transaction.new(n, a, r.auxiliary_data());
      this.txHex = c.to_hex();
    }
  };
  buildTx = () => {
    const e = this.txBuilder.build_tx();
    this.txHex = e.to_hex();
  };
  queueInput = () => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "Script")
      if (this.txInQueueItem.scriptTxIn) {
        if (!this.txInQueueItem.scriptTxIn.datumSource)
          throw Error("Script input does not contain datum information");
        if (!this.txInQueueItem.scriptTxIn.redeemer)
          throw Error("Script input does not contain redeemer information");
        if (!this.txInQueueItem.scriptTxIn.scriptSource)
          throw Error("Script input does not contain script information");
      } else
        throw Error("Script input does not contain script, datum, or redeemer information");
    this.meshTxBuilderBody.inputs.push(this.txInQueueItem), this.txInQueueItem = void 0;
  };
  queueMint = () => {
    if (!this.mintItem)
      throw Error("Undefined mint");
    if (!this.mintItem.scriptSource)
      throw Error("Missing mint script information");
    this.meshTxBuilderBody.mints.push(this.mintItem), this.mintItem = void 0;
  };
  makePlutusScriptSource = (e) => {
    const t = i.ScriptHash.from_hex(e.spendingScriptHash), r = i.TransactionInput.new(i.TransactionHash.from_hex(e.txHash), e.txIndex);
    return i.PlutusScriptSource.new_ref_input_with_lang_ver(t, r, St[e.version]);
  };
  removeDuplicateInputs = () => {
    const e = this.meshTxBuilderBody.inputs, t = (n) => `${n.txHash}#${n.txIndex}`, r = [];
    for (let n = 0; n < e.length; n++) {
      const a = t(e[n].txIn);
      r.includes(a) ? (e.splice(n, 1), n--) : r.push(a);
    }
  };
  addAllInputs = (e) => {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      switch (r.type) {
        case "PubKey":
          this.addTxIn(r);
          break;
        case "Script":
          this.addScriptTxIn(r);
          break;
      }
    }
  };
  addTxIn = (e) => {
    this.txBuilder.add_input(i.Address.from_bech32(e.txIn.address), i.TransactionInput.new(i.TransactionHash.from_hex(e.txIn.txHash), e.txIn.txIndex), bt(e.txIn.amount));
  };
  addScriptTxIn = ({ scriptTxIn: e, txIn: t }) => {
    let r;
    const { datumSource: n, scriptSource: a, redeemer: c } = e;
    if (n.type === "Provided")
      r = i.DatumSource.new(this.castDataToPlutusData(n.data));
    else {
      const A = i.TransactionInput.new(i.TransactionHash.from_hex(n.txHash), n.txIndex);
      r = i.DatumSource.new_ref_input(A);
    }
    let l;
    a.type == "Inline" ? l = this.makePlutusScriptSource(a.txInInfo) : l = i.PlutusScriptSource.new(i.PlutusScript.from_hex_with_version(a.script.code, St[a.script.version]));
    const p = i.Redeemer.new(i.RedeemerTag.new_spend(), i.BigNum.from_str("0"), this.castDataToPlutusData(c.data), i.ExUnits.new(i.BigNum.from_str(String(c.exUnits.mem)), i.BigNum.from_str(String(c.exUnits.steps))));
    this.txBuilder.add_plutus_script_input(i.PlutusWitness.new_with_ref(l, r, p), i.TransactionInput.new(i.TransactionHash.from_hex(t.txHash), t.txIndex), bt(t.amount));
  };
  addAllOutputs = (e) => {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this.addOutput(r);
    }
  };
  addOutput = ({ amount: e, address: t, datum: r, referenceScript: n }) => {
    const a = bt(e), c = a.multiasset();
    if (a.is_zero() && c === void 0)
      throw Error("Invalid output amount");
    let l = i.TransactionOutputBuilder.new().with_address(It(t));
    r && r.type === "Hash" && (l = l.with_data_hash(i.hash_plutus_data(this.castDataToPlutusData(r.data)))), r && r.type === "Inline" && (l = l.with_plutus_data(this.castDataToPlutusData(r.data))), n && (l = l.with_script_ref(i.ScriptRef.new_plutus_script(i.PlutusScript.from_hex_with_version(n.code, St[n.version]))));
    const p = l.next();
    if (c) {
      const A = a.coin().is_zero() ? p.with_asset_and_min_required_coin_by_utxo_cost(c, Ue(this._protocolParams.coinsPerUTxOSize)).build() : p.with_coin_and_asset(a.coin(), c).build();
      this.txBuilder.add_output(A);
    } else {
      const A = p.with_coin(a.coin()).build();
      this.txBuilder.add_output(A);
    }
  };
  addAllCollaterals = (e) => {
    const t = i.TxInputsBuilder.new();
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      this.addCollateral(t, n);
    }
    this.txBuilder.set_collateral(t);
  };
  addCollateral = (e, t) => {
    e.add_input(i.Address.from_bech32(t.txIn.address), i.TransactionInput.new(i.TransactionHash.from_hex(t.txIn.txHash), t.txIn.txIndex), bt(t.txIn.amount));
  };
  addCollateralReturn = (e) => {
    var r;
    const t = (r = this.txBuilder.get_fee_if_set()) == null ? void 0 : r.to_js_value();
    if (t) {
      const n = Math.ceil(this._protocolParams.collateralPercent * Number(t) / 100);
      this.txBuilder.set_total_collateral_and_return(i.BigNum.from_str(String(n)), i.Address.from_bech32(e));
    }
  };
  addAllReferenceInputs = (e) => {
    e.forEach((t) => {
      this.addReferenceInput(t);
    });
  };
  addReferenceInput = ({ txHash: e, txIndex: t }) => {
    const r = i.TransactionInput.new(i.TransactionHash.from_hex(e), t);
    this.txBuilder.add_reference_input(r);
  };
  addAllMints = (e) => {
    const t = i.MintBuilder.new();
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const a = e[n];
      if (!a.scriptSource)
        throw Error("Mint script is expected to be provided");
      if (a.type === "Plutus") {
        if (!a.redeemer)
          throw Error("Missing mint redeemer information");
        this.addPlutusMint(t, a, r), r++;
      } else
        a.type === "Native" && this.addNativeMint(t, a);
    }
    this.txBuilder.set_mint_builder(t);
  };
  addPlutusMint = (e, { redeemer: t, policyId: r, scriptSource: n, assetName: a, amount: c }, l) => {
    const p = i.Redeemer.new(i.RedeemerTag.new_mint(), i.BigNum.from_str(String(l)), this.castDataToPlutusData(t.data), i.ExUnits.new(i.BigNum.from_str(String(t.exUnits.mem)), i.BigNum.from_str(String(t.exUnits.steps)))), A = n.type === "Reference Script" ? i.PlutusScriptSource.new_ref_input_with_lang_ver(i.ScriptHash.from_hex(r), i.TransactionInput.new(i.TransactionHash.from_hex(n.txHash), n.txIndex), St[n.version]) : i.PlutusScriptSource.new(i.PlutusScript.from_hex_with_version(n.script.code, St[n.script.version]));
    e.add_asset(i.MintWitness.new_plutus_script(A, p), i.AssetName.new(Buffer.from(a, "hex")), i.Int.from_str(c));
  };
  addNativeMint = (e, { scriptSource: t, assetName: r, amount: n }) => {
    if (t.type === "Reference Script")
      throw Error("Native mint cannot have reference script");
    e.add_asset(i.MintWitness.new_native_script(i.NativeScript.from_hex(t.script.code)), i.AssetName.new(Buffer.from(r, "hex")), i.Int.from_str(n));
  };
  decimalToFraction(e) {
    const t = 10 ** e.toString().split(".")[1].length;
    return [e * t, t];
  }
  toPoolParams = (e) => {
    const t = this.decimalToFraction(e.margin), r = i.Relays.new();
    e.relays.forEach((c) => {
      r.add(Or(c));
    });
    const n = i.RewardAddress.from_address(i.Address.from_bech32(e.rewardAddress));
    if (n === void 0)
      throw new Error("Reward address is invalid");
    const a = i.Ed25519KeyHashes.new();
    return e.owners.forEach((c) => {
      a.add(i.Ed25519KeyHash.from_hex(c));
    }), i.PoolParams.new(i.Ed25519KeyHash.from_hex(e.operator), i.VRFKeyHash.from_hex(e.VRFKeyHash), i.BigNum.from_str(e.pledge), i.BigNum.from_str(e.cost), i.UnitInterval.new(i.BigNum.from_str(t[0].toString()), i.BigNum.from_str(t[1].toString())), n, a, r, e.metadata ? i.PoolMetadata.from_json(zt.exports.stringify(e.metadata)) : void 0);
  };
  addCertificate = (e, t) => {
    switch (t.type) {
      case "RegisterPool":
        e.add(i.Certificate.new_pool_registration(i.PoolRegistration.new(this.toPoolParams(t.poolParams))));
        break;
      case "RegisterStake":
        e.add(i.Certificate.new_stake_registration(i.StakeRegistration.new(i.StakeCredential.from_keyhash(i.Ed25519KeyHash.from_hex(t.stakeKeyHash)))));
        break;
      case "DelegateStake":
        e.add(i.Certificate.new_stake_delegation(i.StakeDelegation.new(i.StakeCredential.from_keyhash(i.Ed25519KeyHash.from_hex(t.stakeKeyHash)), t.poolId.startsWith("pool") ? i.Ed25519KeyHash.from_bech32(t.poolId) : i.Ed25519KeyHash.from_hex(t.poolId))));
        break;
      case "DeregisterStake":
        e.add(i.Certificate.new_stake_deregistration(i.StakeDeregistration.new(i.StakeCredential.from_keyhash(i.Ed25519KeyHash.from_hex(t.stakeKeyHash)))));
        break;
      case "RetirePool":
        e.add(i.Certificate.new_pool_retirement(i.PoolRetirement.new(t.poolId.startsWith("pool") ? i.Ed25519KeyHash.from_bech32(t.poolId) : i.Ed25519KeyHash.from_hex(t.poolId), t.epoch)));
    }
  };
  queueAllLastItem = () => {
    this.txOutput && (this.meshTxBuilderBody.outputs.push(this.txOutput), this.txOutput = void 0), this.txInQueueItem && this.queueInput(), this.collateralQueueItem && (this.meshTxBuilderBody.collaterals.push(this.collateralQueueItem), this.collateralQueueItem = void 0), this.mintItem && this.queueMint();
  };
  addAllCertificates = (e) => {
    const t = i.Certificates.new();
    e.forEach((r) => {
      this.addCertificate(t, r);
    }), this.txBuilder.set_certs(t);
  };
  addCostModels = () => {
    this.txBuilder.calc_script_data_hash(i.TxBuilderConstants.plutus_vasil_cost_models());
  };
  addChange = (e) => {
    this.txBuilder.add_change_if_needed(i.Address.from_bech32(e));
  };
  addValidityRange = ({ invalidBefore: e, invalidHereafter: t }) => {
    e && this.txBuilder.set_validity_start_interval_bignum(i.BigNum.from_str(e.toString())), t && this.txBuilder.set_ttl_bignum(i.BigNum.from_str(t.toString()));
  };
  addAllRequiredSignatures = (e) => {
    e.forEach((t) => {
      this.txBuilder.add_required_signer(i.Ed25519KeyHash.from_hex(t));
    });
  };
  addAllMetadata = (e) => {
    e.forEach(({ tag: t, metadata: r }) => {
      this.txBuilder.add_json_metadatum(i.BigNum.from_str(t), zt.exports.stringify(r));
    });
  };
  updateRedeemer = (e, t) => {
    t.forEach((r) => {
      switch (r.tag) {
        case "SPEND": {
          const n = e.inputs[r.index];
          n.type == "Script" && n.scriptTxIn.redeemer && (n.scriptTxIn.redeemer.exUnits.mem = Math.floor(r.budget.mem * this.txEvaluationMultiplier), n.scriptTxIn.redeemer.exUnits.steps = Math.floor(r.budget.steps * this.txEvaluationMultiplier));
          break;
        }
        case "MINT": {
          const n = e.mints[r.index];
          n.type == "Plutus" && n.redeemer && (n.redeemer.exUnits.mem = Math.floor(r.budget.mem * this.txEvaluationMultiplier), n.redeemer.exUnits.steps = Math.floor(r.budget.steps * this.txEvaluationMultiplier));
          break;
        }
      }
    });
  };
  castRawDataToJsonString = (e) => typeof e == "object" ? zt.exports.stringify(e) : e;
  castDataToPlutusData = ({ type: e, content: t }) => e === "Mesh" ? Ot(t) : e === "CBOR" ? i.PlutusData.from_hex(t) : i.PlutusData.from_json(t, i.PlutusDatumSchema.DetailedSchema);
}
class bn extends Zs {
  _fetcher;
  _submitter;
  _evaluator;
  queriedTxHashes = /* @__PURE__ */ new Set();
  queriedUTxOs = {};
  constructor({ fetcher: e, submitter: t, evaluator: r, isHydra: n = !1 }) {
    super(), e && (this._fetcher = e), t && (this._submitter = t), r && (this._evaluator = r), n && (this.isHydra = !0);
  }
  complete = async (e) => {
    e ? this.meshTxBuilderBody = e : this.queueAllLastItem();
    const { inputs: t, collaterals: r } = this.meshTxBuilderBody, n = [...t, ...r].filter((a) => !this.isInputComplete(a));
    if (console.log("Incomplete UTxO", n), await this.queryAllTxInfo(n), console.log("Incomplete UTxO", n), n.forEach((a) => {
      this.completeTxInformation(a);
    }), this.completeSync(e), this._evaluator) {
      const a = await this._evaluator.evaluateTx(this.txHex);
      this.updateRedeemer(this.meshTxBuilderBody, a), this.completeSync(e);
    }
    return this;
  };
  submitTx = async (e) => {
    var r;
    return await ((r = this._submitter) == null ? void 0 : r.submitTx(e));
  };
  getUTxOInfo = async (e) => {
    var r;
    let t = [];
    this.queriedTxHashes.has(e) || (console.log("Query", e), this.queriedTxHashes.add(e), t = await ((r = this._fetcher) == null ? void 0 : r.fetchUTxOs(e)) || [], this.queriedUTxOs[e] = t);
  };
  queryAllTxInfo = (e) => {
    var r;
    const t = [];
    if (e.length > 0 && !this._fetcher)
      throw Error("Transaction information is incomplete while no fetcher instance is provided");
    for (let n = 0; n < e.length; n++) {
      const a = e[n];
      this.isInputInfoComplete(a) || t.push(this.getUTxOInfo(a.txIn.txHash)), a.type === "Script" && ((r = a.scriptTxIn.scriptSource) == null ? void 0 : r.type) === "Inline" && !this.isRefScriptInfoComplete(a) && t.push(this.getUTxOInfo(a.scriptTxIn.scriptSource.txInInfo.txHash));
    }
    return Promise.all(t);
  };
  completeTxInformation = (e) => {
    var t;
    if (!this.isInputInfoComplete(e)) {
      const r = this.queriedUTxOs[e.txIn.txHash], n = r == null ? void 0 : r.find((l) => l.input.outputIndex === e.txIn.txIndex), a = n == null ? void 0 : n.output.amount, c = n == null ? void 0 : n.output.address;
      if (!a || a.length === 0)
        throw Error(`Couldn't find value information for ${e.txIn.txHash}#${e.txIn.txIndex}`);
      if (e.txIn.amount = a, e.type === "PubKey") {
        if (!c || c === "")
          throw Error(`Couldn't find address information for ${e.txIn.txHash}#${e.txIn.txIndex}`);
        e.txIn.address = c;
      }
    }
    if (e.type === "Script" && ((t = e.scriptTxIn.scriptSource) == null ? void 0 : t.type) == "Inline" && !this.isRefScriptInfoComplete(e)) {
      const r = e.scriptTxIn.scriptSource.txInInfo, a = this.queriedUTxOs[r.txHash].find((c) => c.input.outputIndex === r.txIndex);
      if (!a)
        throw Error(`Couldn't find script reference utxo for ${r.txHash}#${r.txIndex}`);
      r.spendingScriptHash = a == null ? void 0 : a.output.scriptHash;
    }
  };
  isInputComplete = (e) => e.type === "PubKey" ? this.isInputInfoComplete(e) : e.type === "Script" ? this.isInputInfoComplete(e) && this.isRefScriptInfoComplete(e) : !0;
  isInputInfoComplete = (e) => {
    const { amount: t, address: r } = e.txIn;
    return !(e.type === "PubKey" && (!t || !r) || e.type === "Script" && !t);
  };
  isRefScriptInfoComplete = (e) => {
    var r;
    const { scriptSource: t } = e.scriptTxIn;
    return !((t == null ? void 0 : t.type) === "Inline" && !((r = t.txInInfo) != null && r.spendingScriptHash));
  };
}
class rt {
  _networkId;
  _encryptedSecret;
  constructor(e, t) {
    this._networkId = e, this._encryptedSecret = t;
  }
  getAccount(e, t) {
    return this.accountContext(e, t, (r, n) => {
      const a = gr(this._networkId, r.to_public().hash(), n.to_public().hash()).to_address().to_bech32(), c = mr(this._networkId, r.to_public().hash()).to_address().to_bech32(), l = Oe(this._networkId, n.to_public().hash()).to_address().to_bech32();
      return {
        baseAddress: a,
        enterpriseAddress: c,
        rewardAddress: l
      };
    });
  }
  signData(e, t, r, n) {
    try {
      return this.accountContext(e, t, (a, c) => {
        const l = { payload: n }, p = {
          address: rt.resolveAddress(this._networkId, r, a, c),
          key: r.startsWith("stake") ? c : a
        }, { coseSign1: A, coseKey: C } = us(l, p);
        return { signature: A, key: C };
      });
    } catch (a) {
      throw new Error(`An error occurred during signData: ${a}.`);
    }
  }
  signTx(e, t, r, n, a) {
    try {
      const c = Nr(Gs(n));
      return this.accountContext(e, t, (l, p) => {
        const A = i.Vkeywitnesses.new();
        return rt.resolveSigners(n, r, l.to_public().hash().to_hex()).forEach((E) => {
          if (E === l.to_public().hash().to_hex())
            A.add(i.make_vkey_witness(c, l));
          else if (E === p.to_public().hash().to_hex())
            A.add(i.make_vkey_witness(c, p));
          else if (a === !1)
            throw new Error(`Missing key witness for: ${E}`);
        }), A;
      });
    } catch (c) {
      throw new Error(`An error occurred during signTx: ${c}.`);
    }
  }
  static encryptMnemonic(e, t) {
    const r = _r(e.join(" ")), n = Hr(r), a = lt(n.as_bytes());
    return n.free(), rt.encrypt(a, t);
  }
  static encryptPrivateKey(e, t) {
    const r = i.Bip32PrivateKey.from_bech32(e), n = lt(r.as_bytes());
    return r.free(), rt.encrypt(n, t);
  }
  static encryptSigningKeys(e, t, r) {
    const n = rt.encrypt(e.slice(4), r), a = rt.encrypt(t.slice(4), r);
    return [n, a];
  }
  static generateMnemonic(e = 256) {
    return Lr(e).split(" ");
  }
  accountContext(e, t, r) {
    const { paymentKey: n, stakeKey: a } = rt.resolveKeys(e, t, this._encryptedSecret), c = r(n, a);
    return n.free(), a.free(), c;
  }
  static decrypt(e, t) {
    try {
      return i.decrypt_with_password(ot(t), e);
    } catch {
      throw new Error("The password is incorrect.");
    }
  }
  static encrypt(e, t) {
    const r = Ir("0123456789abcdef"), n = r(64), a = r(24);
    return i.encrypt_with_password(ot(t), n, a, e);
  }
  static resolveAddress(e, t, r, n) {
    const a = [
      gr(e, r.to_public().hash(), n.to_public().hash()),
      mr(e, r.to_public().hash()),
      Oe(e, n.to_public().hash())
    ].find((c) => c.to_address().to_bech32() === t);
    if (a !== void 0)
      return a.to_address();
    throw new Error(`Address: ${t} doesn't belong to this account.`);
  }
  static resolveKeys(e, t, r) {
    if (typeof r == "string") {
      const c = rt.decrypt(r, t);
      return Ps(c, e);
    }
    const n = rt.decrypt(r[0], t), a = rt.decrypt(r[1], t);
    return {
      paymentKey: i.PrivateKey.from_hex(n),
      stakeKey: i.PrivateKey.from_hex(a)
    };
  }
  static resolveSigners(e, t, r) {
    const n = (l) => {
      const p = (T, Q = [], R = 0) => {
        var O, M, z, X, D;
        if (T === void 0 || R >= T.len())
          return Q;
        const j = T.get(R), Y = new Array();
        switch (j.kind()) {
          case i.CertificateKind.StakeDeregistration: {
            const F = (O = j.as_stake_deregistration()) == null ? void 0 : O.stake_credential(), q = (F == null ? void 0 : F.kind()) === i.StakeCredKind.Key ? F.to_keyhash() : void 0;
            q && Y.push(q.to_hex());
            break;
          }
          case i.CertificateKind.StakeDelegation: {
            const F = (M = j.as_stake_delegation()) == null ? void 0 : M.stake_credential(), q = (F == null ? void 0 : F.kind()) === i.StakeCredKind.Key ? F.to_keyhash() : void 0;
            q && Y.push(q.to_hex());
            break;
          }
          case i.CertificateKind.PoolRegistration: {
            const F = (z = j.as_pool_registration()) == null ? void 0 : z.pool_params().pool_owners();
            Y.push(...C(F));
            break;
          }
          case i.CertificateKind.PoolRetirement: {
            const F = (X = j.as_pool_retirement()) == null ? void 0 : X.pool_keyhash();
            F && Y.push(F.to_hex());
            break;
          }
          case i.CertificateKind.MoveInstantaneousRewardsCert: {
            const F = (D = j.as_move_instantaneous_rewards_cert()) == null ? void 0 : D.move_instantaneous_reward().as_to_stake_creds();
            if (F)
              for (let q = 0; q < F.len(); q += 1) {
                const W = F.keys().get(q), st = W.kind() === i.StakeCredKind.Key ? W.to_keyhash() : void 0;
                st && Y.push(st.to_hex());
              }
            break;
          }
        }
        return p(T, [...Q, ...Y], R + 1);
      }, A = (T, Q = [], R = 0) => {
        if (T === void 0 || R >= T.len())
          return Q;
        const j = T.get(R).index(), Y = T.get(R).transaction_id(), O = t.find((M) => M.input.outputIndex === j && M.input.txHash === Y.to_hex()) !== void 0 ? r : "OUR_PRINCESS_IS_IN_ANOTHER_CASTLE";
        return A(T, [...Q, O], R + 1);
      }, C = (T, Q = [], R = 0) => T === void 0 || R >= T.len() ? Q : C(T, [...Q, T.get(R).to_hex()], R + 1), E = (T, Q = [], R = 0) => {
        if (T === void 0 || R >= T.len())
          return Q;
        const j = T.keys().get(R).payment_cred(), Y = j.kind() === i.StakeCredKind.Key ? j.to_keyhash() : void 0;
        return E(T, Y ? [...Q, Y.to_hex()] : Q, R + 1);
      }, w = l.certs(), b = l.collateral(), P = l.inputs(), k = l.required_signers(), N = l.withdrawals();
      return [
        ...p(w),
        ...A(b),
        ...A(P),
        ...C(k),
        ...E(N)
      ];
    }, a = (l) => {
      const p = (C, E = []) => {
        var w, b, P, k;
        if (C)
          for (let N = 0; N < C.len(); N += 1) {
            const T = C.get(N);
            switch (T.kind()) {
              case i.NativeScriptKind.ScriptPubkey: {
                const Q = (w = T.as_script_pubkey()) == null ? void 0 : w.addr_keyhash().to_hex();
                return Q ? [...E, Q] : E;
              }
              case i.NativeScriptKind.ScriptAll:
                return p((b = T.as_script_all()) == null ? void 0 : b.native_scripts(), E);
              case i.NativeScriptKind.ScriptAny:
                return p((P = T.as_script_any()) == null ? void 0 : P.native_scripts(), E);
              case i.NativeScriptKind.ScriptNOfK:
                return p((k = T.as_script_n_of_k()) == null ? void 0 : k.native_scripts(), E);
            }
          }
        return E;
      }, A = l.native_scripts();
      return [
        ...p(A)
      ];
    }, c = pt(e);
    return /* @__PURE__ */ new Set([
      ...n(c.body()),
      ...a(c.witness_set())
    ]);
  }
}
const At = "MARI0TIME";
class Qn {
  _fetcher;
  _submitter;
  _wallet;
  constructor(e) {
    switch (this._fetcher = e.fetcher, this._submitter = e.submitter, e.key.type) {
      case "mnemonic":
        this._wallet = new rt(e.networkId, rt.encryptMnemonic(e.key.words, At));
        break;
      case "root":
        this._wallet = new rt(e.networkId, rt.encryptPrivateKey(e.key.bech32, At));
        break;
      case "cli":
        this._wallet = new rt(e.networkId, rt.encryptSigningKeys(e.key.payment, e.key.stake ?? "f0".repeat(34), At));
    }
  }
  getBaseAddress(e = 0) {
    return this._wallet.getAccount(e, At).baseAddress;
  }
  getPaymentAddress(e = 0) {
    return this._wallet.getAccount(e, At).enterpriseAddress;
  }
  getRewardAddress(e = 0) {
    return this._wallet.getAccount(e, At).rewardAddress;
  }
  getUsedAddress(e = 0) {
    const t = this._wallet.getAccount(e, At);
    return It(t.enterpriseAddress);
  }
  getUsedCollateral(e = ft.maxCollateralInputs) {
    throw new Error("getUsedCollateral not implemented.");
  }
  async getUsedUTxOs(e = 0) {
    const t = this._wallet.getAccount(e, At);
    return (await this._fetcher.fetchAddressUTxOs(t.enterpriseAddress)).map((n) => xt(n));
  }
  signData(e, t, r = 0) {
    try {
      return this._wallet.signData(r, At, e, t);
    } catch (n) {
      throw new Error(`[AppWallet] An error occurred during signData: ${n}.`);
    }
  }
  async signTx(e, t = !1, r = 0) {
    try {
      const n = this._wallet.getAccount(r, At), a = await this._fetcher.fetchAddressUTxOs(n.enterpriseAddress), c = this._wallet.signTx(r, At, a, e, t), l = pt(e), p = l.witness_set(), A = Ke(p, c);
      return p.set_vkeys(A), i.Transaction.new(l.body(), p, l.auxiliary_data()).to_hex();
    } catch (n) {
      throw new Error(`[AppWallet] An error occurred during signTx: ${n}.`);
    }
  }
  async signTxs(e, t) {
    return console.log("unimplemented", e, t), [];
  }
  submitTx(e) {
    return this._submitter.submitTx(e);
  }
  static brew(e = 256) {
    return rt.generateMnemonic(e);
  }
}
class He {
  _walletInstance;
  _walletName;
  walletInstance;
  constructor(e, t) {
    this._walletInstance = e, this._walletName = t, this.walletInstance = { ...e };
  }
  static getInstalledWallets() {
    return window.cardano === void 0 ? [] : We.filter((e) => window.cardano[e] !== void 0).map((e) => ({
      name: window.cardano[e].name,
      icon: window.cardano[e].icon,
      version: window.cardano[e].apiVersion
    }));
  }
  static async enable(e) {
    try {
      const t = await He.resolveInstance(e);
      if (t !== void 0)
        return new He(t, e);
      throw new Error(`Couldn't create an instance of wallet: ${e}`);
    } catch (t) {
      throw new Error(`[BrowserWallet] An error occurred during enable: ${JSON.stringify(t)}.`);
    }
  }
  async getBalance() {
    const e = await this._walletInstance.getBalance();
    return Kr(Rs(e));
  }
  async getChangeAddress() {
    const e = await this._walletInstance.getChangeAddress();
    return Lt(e).to_bech32();
  }
  async getCollateral(e = ft.maxCollateralInputs) {
    return (await this.getUsedCollateral(e)).map((r) => Ie(r));
  }
  getNetworkId() {
    return this._walletInstance.getNetworkId();
  }
  async getRewardAddresses() {
    return (await this._walletInstance.getRewardAddresses()).map((t) => Lt(t).to_bech32());
  }
  async getUnusedAddresses() {
    return (await this._walletInstance.getUnusedAddresses()).map((t) => Lt(t).to_bech32());
  }
  async getUsedAddresses() {
    return (await this._walletInstance.getUsedAddresses()).map((t) => Lt(t).to_bech32());
  }
  async getUtxos(e = void 0) {
    return (await this.getUsedUTxOs(e)).map((r) => Ie(r));
  }
  signData(e, t) {
    const r = It(e).to_hex();
    return this._walletInstance.signData(r, ot(t));
  }
  async signTx(e, t = !1) {
    try {
      const r = pt(e), n = r.witness_set(), a = await this._walletInstance.signTx(e, t), c = dr(a).vkeys() ?? i.Vkeywitnesses.new(), l = Ke(n, c);
      return n.set_vkeys(l), lt(i.Transaction.new(r.body(), n, r.auxiliary_data()).to_bytes());
    } catch (r) {
      throw new Error(`[BrowserWallet] An error occurred during signTx: ${JSON.stringify(r)}.`);
    }
  }
  async signTxs(e, t = !1) {
    let r;
    switch (this._walletName) {
      case "Typhon Wallet":
        this._walletInstance.signTxs && (r = await this._walletInstance.signTxs(e, t));
        break;
      default:
        this._walletInstance.signTxs ? r = await this._walletInstance.signTxs(e.map((a) => ({
          cbor: a,
          partialSign: t
        }))) : this._walletInstance.experimental.signTxs && (r = await this._walletInstance.experimental.signTxs(e.map((a) => ({
          cbor: a,
          partialSign: t
        }))));
        break;
    }
    if (!r)
      throw new Error("Wallet does not support signTxs");
    const n = [];
    for (let a = 0; a < r.length; a++) {
      const c = pt(e[a]), l = c.witness_set(), p = dr(r[a]).vkeys() ?? i.Vkeywitnesses.new(), A = Ke(l, p);
      l.set_vkeys(A);
      const C = lt(i.Transaction.new(c.body(), l, c.auxiliary_data()).to_bytes());
      n.push(C);
    }
    return n;
  }
  submitTx(e) {
    return this._walletInstance.submitTx(e);
  }
  async getUsedAddress() {
    const e = await this._walletInstance.getUsedAddresses();
    return Lt(e[0]);
  }
  async getUsedCollateral(e = ft.maxCollateralInputs) {
    return (await this._walletInstance.experimental.getCollateral() ?? []).map((r) => hr(r)).slice(0, e);
  }
  async getUsedUTxOs(e = void 0) {
    const t = e ? bt(e).to_hex() : void 0;
    return (await this._walletInstance.getUtxos(t) ?? []).map((n) => hr(n));
  }
  async getAssets() {
    return (await this.getBalance()).filter((t) => t.unit !== "lovelace").map((t) => {
      const r = t.unit.slice(0, Ct), n = t.unit.slice(Ct), a = Ls(r, n);
      return {
        unit: t.unit,
        policyId: r,
        assetName: Ge(n),
        fingerprint: a,
        quantity: t.quantity
      };
    });
  }
  async getLovelace() {
    const t = (await this.getBalance()).find((r) => r.unit === "lovelace");
    return t !== void 0 ? t.quantity : "0";
  }
  async getPolicyIdAssets(e) {
    return (await this.getAssets()).filter((r) => r.policyId === e);
  }
  async getPolicyIds() {
    const e = await this.getBalance();
    return Array.from(new Set(e.map((t) => t.unit.slice(0, Ct)))).filter((t) => t !== "lovelace");
  }
  static resolveInstance(e) {
    if (window.cardano === void 0)
      return;
    const t = We.map((r) => window.cardano[r]).filter((r) => r !== void 0).find((r) => r.name.toLowerCase() === e.toLowerCase());
    return t == null ? void 0 : t.enable();
  }
}
export {
  Qn as AppWallet,
  yn as BlockfrostProvider,
  He as BrowserWallet,
  rt as EmbeddedWallet,
  Sn as ForgeScript,
  xn as InfuraProvider,
  wn as KoiosProvider,
  En as MaestroProvider,
  bn as MeshTxBuilder,
  Cn as OgmiosProvider,
  Bn as TangoProvider,
  Dt as Transaction,
  an as checkSignature,
  pn as generateNonce,
  jr as isNetwork,
  rs as keepRelevant,
  nn as largestFirst,
  ss as largestFirstMultiAsset,
  Kt as parseAssetUnit,
  S as parseHttpError,
  In as readPlutusData,
  _n as readTransaction,
  on as resolveDataHash,
  cn as resolveEpochNo,
  Ls as resolveFingerprint,
  un as resolveLanguageView,
  ln as resolveNativeScriptHash,
  Yt as resolvePaymentKeyHash,
  hn as resolvePlutusScriptAddress,
  dn as resolvePlutusScriptHash,
  fn as resolvePoolId,
  gn as resolvePrivateKey,
  we as resolveRewardAddress,
  mn as resolveScriptRef,
  An as resolveSlotNo,
  re as resolveStakeKeyHash,
  Fr as resolveTxFees,
  Gs as resolveTxHash
};
